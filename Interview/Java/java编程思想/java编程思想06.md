####类再生####
>java中为了代码的复用和再生，可以使用类继承和类合成的形式。

1. 类继承是指创建一个新类作为现有类的的一个“类型”；我们可以原样的采取现有类的代码，同时可以加上新代码而对现有类又不会产生影响。
2. 类合成是指在新类中创建原有类的对象，利用原有类的对象来操作原有类的代码，这只是一种简单重复利用代码的功能。

#####类合成#####
>通过类合成来达到类复用的过程中，需要注意几点

1. 类中的合成类的对象编译器并不会主动的去调用默认构造函数，它会被默认初始值为null。
2. 合成类的对象的初始化我们可以在其对象定义的时候进行初始化化，或者在类的构建器里进行初始化，不然在合适类对象使用之前进行初始化的工作；总之在使用合成类对象之前，其对象必须得到正确的初始化值，否者使用它会产生一个NullPointException违例。

#####类继承#####
>java是单继承的，创建一个类时默认会从标准根类Object中继承，在类继承的过程中需要注意几点

1. 通过关键字extends来继承基础类，新类可以自动获得基础类的所有数据成员以及方法。
2. 在衍生类的方法中可以通过关键字super来调用基础类的方法
3. 衍生类可以加入自己的方法和数据成员以便对基础类进行扩展
4. 创建衍生类的过程中，其实会在衍生类中创建基础类的子对象；为了使得基础类的子对象在衍生类中得到正确的初始化，需要在衍生类中调用基础类的构建器;
	* 对于无参构建器，JAVA会自动的插入基础类构建器的调用；
	* 含有自变量的构建器，则需要我们明确指定调用基础类的构建器且在衍生类的构建器中是需要首先调用的。

#####垃圾收集#####
1. Java不存在C++的“破坏器”的概念，所有的垃圾都有垃圾收集器进行统一处理和回收。
2. 垃圾收集器何时进行回收，我们并不知道，所以当一个类中希望清除什么东西，必须写一个特别的方法，明确来做这些事。
3. 在自己的清除方法中，必须注意对基础类以及成员对象清除方法的调用顺序；首先完成对类有关的所有特殊工作，然后调用基础类的清除方法。
3. 因为垃圾收集器的收集工作的时间是不可预期的，所以不要依赖finalize()方法。

#####合成还是继承#####
1. 如果想使用新类内部一个现有类的特性，而不想使用它的接口，通常选择合成。
2. 继承是取得一个现成的类，并制作它的一个特殊版本。
3. “属于”关系是用继承来表达的，“包含”关系是用合成来表达的，在选择继承还是合成时，可以参考它们之间的关系。
#####protected#####
理想的情况下，一个类的数据成员都应该被设计成private，以达到数据的隐藏；但在某些情况下，基础类为了使得其衍生类和包中的类可用时，可以将其数据成员设计成protected以达到这种效果。
#####上溯造型#####
1. 继承是对新类和基础类之间的关系的一种表达，可以总结为：“新类属于现有类的一种类型”。
2. 将衍生类转换成基础类类型的过程叫做“上溯造型”，这是一种从特殊到常规的类型，可以将衍生类看作是基础类的一个超集。
3. 判断是否使用合成还是继承，我们还可以通过是否需要从衍生类上溯造型到基础类，如果需要则使用继承，否者使用合成。
#####final#####
final声明代表这个东西不能改变。可以应用在数据、方法和类中。
######final数据######
final修饰数据主要分为成员字段和方法自变量。
修饰成员字段时有几点值得注意

*1. 编译期基本数据常数，它的值永远不会改变；但需要注意的是final的修饰的常数并不一定会在编译期就能确定。如下面例子中的data会在运行期进行确定
<pre><code>
final int data = (int)(Math.random() * 20);
</code></pre>
*2. 句柄对象常数，是指不能将句柄对象指向另一个对象；但是句柄对象本身的数据是可以修改的。
*3. final的数据可以在定义时为空白，我们只需在使用final数据前对它进行正确的初始化即可。
*4. final和static final 的区别主要是final修饰的字段是指其所属的类对象的，每个对象可以有所不同;而static final是所属类本身的，所有的对象都是相同。

final方法自变量通用分为其修饰的变量是否是基本变量还是句柄对象；当修饰基本变量指在方法内容的使用过程中不能改变其值，而修饰句柄对象指在方法内部不能将其句柄执行其他对象，但是可以修改其句柄对象的值。
######final方法######
final修饰方法主要有两方面的用途和一个注意点
1. 给方法上锁，防止任何继承类改变它的本来含义，也就是说不可给覆盖或改写。
2. 提高程序效率，使用final修饰方法时，编译器在执行这个方法时会采用嵌入的方法来调用（会使用方法主体内实际代码的一个副本替换方法调用）。
3. private方法本身会自动成为final，因为我们无需为其修饰。
######final类######
修饰final类表示这个类不能被继承，因为其禁止了继承，所以其所有的方法被默认为final
