###多形性###
>多行性也叫多态性是面向对象设计语言的第三种最基本的特性（抽象，继承，多态），多行性从另一个角度将接口从实施细节中分离了出来；实现了“是什么”和“怎么做”两个模块的分离。

多行性跟类的"造型"和"绑定"技术息息相关。
####上溯造型####
1. 将一个类的对象句柄当做其基础类的句柄来使用称为“上溯造型”（继承树的画法基础类位于上方）。
2. “上溯造型”有助于代码的复用；当各类之间只有行为上的差异性，可以将各类进行“上溯造型”到基础类进行调用（基础类会根据“运行期的绑定”来确定来调用哪个类的方法）。
####绑定####
1. 将一个方法的调用同一个方法的主体（对象）连接到一起称为“绑定”。
2. 若在程序运行前执行“绑定”称为“早期绑定”或者“编译期绑定”，当然上溯到基础类的方法调用在程序运行前是没法知道其具体的类型的，这就涉及到另一种“绑定”技术，“运行期绑定”或者“后期绑定”。
3. “运行期绑定”是指在程序运行期间判断对象的类型，并分别找到适当的方法主体进行连接。
4. Java语言中绑定的所有方法都采用“运行期绑定”技术，除非将方法声明为final(解除“运行期绑定”，防止方法的覆盖和重写)。
#####扩展性#####
面向对象中，设计一个便于扩展的程序，很多时候我们需要遵循只与基础类进行通信的原则来设计程序；这样当从基础类中继承新类扩展新的方法时，我们的原先代码就无需进行变动。
#####重载和覆盖#####
1. 重载是指一样东西在不同的地方具有多种含义，这种技术一般使用在类中方法的重载（函数名相同，参数类型或者参数个数来进行区分），相同名字的方法可以有不同的参数和不同的定义。
2. 覆盖是指只有一种含义，原先的含义被后来的含义所取代；存在于衍生类和基础类之间，但是衍生类不能覆盖基础类的私有方法。
####抽象类####
抽象类存在的意义在于基础类的接口在不同的衍生类中具有不同的表示，将衍生类其公共的接口方法抽象至基础类中；因为抽象类不能进行实例化，可以有效的防止基础类没有实例化的前提下调用这些抽象接口方法，同时有利于代码的维护和程序的复用（上溯造型至基础类，运行期绑定方法主体进行调用）。

1. 有abstract修饰的类叫做抽象类，抽象类不能进行实例化。
2. 抽象类中可以包含一个或者多个抽象方法，抽象方法也有abstract进行修饰。
3. 抽象类中可以不包含任何的抽象方法，这时候对于那些想要禁止这个类的所有实例具有非常大的作用。
4. 当抽象类中包含抽象方法时，衍生类必须实现这些抽象方法，否者衍生类也必须是抽象类。
5. 抽象类也可以包括普通方法，变量，静态方法和变量等。
####接口####
接口是抽象类的更进一步，比抽象类更抽象，是对一种事物行为的完全抽象,对于采用了一个特定接口的所有代码都知道那个接口可能会调用什么方法，我们通常把接口用于建立类和类之间的一个“协议”。

1. 接口使用interface进行修饰，不使用class
2. 接口可以含义变量和方法
3. 变量只能是public static final类型（默认类型是public static final）, 方法只能是public（默认是public）
4. java只支持类的单继承，接口存在的另一方面是扩展多重继承的作用。
5. 接口可以继承，可以使用接口扩展另一个接口形成更大的接口。
####内部类####
#####成员内部类#####
1. 成员内部类作为外部类的成员，可以直接使用外部类的所有成员和方法，即使是private;外部类要访问内部类的成员变量和方法，需要通过内部类对象来获取。
2. 除外部类的非static方法内部之外的任何地方生成内部类的一个对象，必须将那个对象的类型设为“外部类名.内部类名”
3. 普通（非内部）类不可设为private或protected--只允许public或者“default”,内部类可以是"private"|"protected"|"default"|"public",使用private修饰内部类可以有效的隐藏细节的实现过程。
4. 成员内部类不能含有static变量和方法，因为成员内部类需要先创建外部类，才能创建它自己的。
#####局部内部类#####
1. 局部内部类，是指内部类定义在方法和作用域内。
2. 局部内部类会随同其他所有东西得到编译，然而，在定义它的那个作用之外，它是不可使用的。
#####匿名内部类#####
1. 没有名字的内部类为匿名内部类，匿名内部类是不能加访问修饰符的。
2. 创建匿名类的一个对象，由new表达式返回的句柄会自动上溯造型成一个匿名类的基础类句柄。
3. 匿名内部类不能拥有一个构建器，但可以使用super()调用匿名类基础类的构建方法。
4. 如果想对匿名内部类的一个对象进行某种形式的初始化，我们可以在定义自己的字段时使用外部方法形参进行初始化；但这时要求外部形参对象为final属性。
5. 匿名内部类可以通过实例初始化，可以达到类似构建器的效果，但是不能对实例初始化进行过载处理。
#####嵌套类#####
1. 嵌套内部类，是指使用static修饰的内部类。
2. 除嵌套内部类，创建其他内部类是，那个类的对象同时拥有指向封装对象的一个链接，所以他们能够访问那个封装对象的成员--勿需取得任何资格。
3. 内部类不可拥有static数据或static内部类，因为内部类必须关联外部类，也就是说需要首先创建外部类再创建内部类。
4. 嵌套类不能声明为private,一般声明为public
#####继承内部类#####
1. 在衍生类中重写基础类的内部类并不会覆盖内部类，而是重载了内部类
2. 衍生类中可以继承基础类中的内部类，当然也可以重写基础类中内部类的方法。
####构建器和多行性####
#####构建器的调用顺序#####
1. 构建器的调用首先调用基础类的构建器，这个步骤会一直重复下去；首先构建的分级结构的根部，然后是下一个衍生类等等，直到抵达最深一层的衍生类。
2. 按照声明顺序对成员进行初始化
3. 调用构造衍生类的主体
#####继承和finalize()
对于设计了某种特殊的清除进程（调用本地方法），这时必须覆盖类的finalize(),在finalize()方法中对垃圾进行回收；如果这个是有基础类进行继承过来的，则必须在finalize()中调用基础类的finalize()方法；否者基础类的初始化根本不会发生。
#####构建器的多行性#####
1. 若构建器内部调用一个动态绑定的方法，会使用那个方法被覆盖的定义，这时可能产生我们意想不到的错误。
2. 构建器的职责是使对象进入就绪状态，如果可能尽量避免调用任何方法，除了final属性的那些方法（也适用private方法，private方法自动具有final属性）
####通过继承进行设计
>多行性特性，使得基础类的行为，在不同的衍生类中有着不同的表现形式。 程序设计过程中，选择继承（多行性）还是合成技术可以遵循如下使用原则：

1. 过度继承会导致程序的设计不必要的复杂起来, 如果不能确定使用哪个，可以优先考虑使用合成。 合成不会使得我们的程序设计进入继承层级结构，同时更加灵活，可以动态选择哪一种类型（以及行为），而继承需要在编译期间准确的知道一种类型。
2. 用继承表达行为的差异，用合成表达状态的变化。
#####纯继承与扩展
1. 衍生类除了基础类的接口之外，不存在其他扩展。 使用的时候基础类可以完美的替换掉衍生类，无需知道与子类的任何相关信息（利用多行性特性）。
2. 纯继承可以避免程序混乱不清，但在定义上存在很大困难，是一种设计极端。
#####下溯造型与运行期类型标识
1. 衍生类对基础类进行扩展的部分不可在基础类中使用。因此需要在使用的时候进行下溯造型成衍生类。
2. 在运行期间对类型进行检查的行为叫做运行期类型标识（RTTI)。