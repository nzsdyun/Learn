##问题整理
1. 冒泡排序的链表实现
	
		1-1：解法一：丑陋版本，每轮都进行N次比较和交换。
        public static ListNode bubbleSort(ListNode head) {
	        for (ListNode x = head; x != null; x = x.next) {
	            for (ListNode y = head; y != null && y.next != null; y = y.next) {
	                if (y.val > y.next.val) {
	                    int temp = y.val;
	                    y.val = y.next.val;
	                    y.next.val = temp;
	                }
	            }
	        }
	        return head;
    	}
		1-2:解法二：优化版本，先获取链表长度，使用变量N记录未排序元素数量，以减少比较和交换次数。
		public static ListNode bubbleSort(ListNode head) {
	        int count = 0;
	        for (ListNode x = head; x != null; x = x.next) {
	            count++;
	        }
	        ListNode p = head;
	        int N;
	        while (count > 1) {
	            N = count;
	            // 使用变量N记录未排序元素数量，以减少比较和交换次数。
	           while (p.next != null && N > 0) {
	               if (p.val > p.next.val) {
	                   int temp = p.val;
	                   p.val = p.next.val;
	                   p.next.val = temp;
	               }
	               p = p.next;
	               N--;
	           }
	           p = head;
	           count--;
	        }
	        return head;
    	}
		1-3：解法三：使用双指针，一个指针用来迭代每轮链表，另一个指针记录最后一个已排序结点。
		public static ListNode bubbleSort(ListNode head) {
	        if (head == null || head.next == null) return head;
	        ListNode cur = head;
	        ListNode tail = null;
	        while (cur.next != tail) {
	            while (cur.next != tail) {
	                if (cur.val > cur.next.val) {
	                    int temp = cur.val;
	                    cur.val = cur.next.val;
	                    cur.next.val = temp;
	                }
	                cur = cur.next;
	            }
	            // 记录最后一个已排序节点
	            tail = cur;
	            cur = head;
	        }
	        return head;
   		}
		1-4： 解法四：交换节点求解， 待续：

2. 快排

   		解法一：交换法
		public static void quickSort(int[] arr, int start, int end) {
	        // 分治思想，选取一个基准值，每次将数组分成两区，左边全部小于基准值，右边全部大于基准值。
	        if (start >= end) {
	            return;
	        }
	        int mid = partition(arr, start, end);
	        quickSort(arr, start, mid - 1);
	        quickSort(arr, mid + 1, end);
	    }
	    
	    public static int partition(int[] a, int start, int end) {
	        // 将第一个元素作为基准值
	        int pivot = a[start];
	        int left = start;
	        int right = end;
	        while (left < right) {
	            // 从右边查找不大于基准值的元素
	            while (a[right] >= pivot && left < right) right--;
	            // 从左边查找不小于基准值的元素
	            while (a[left] <= pivot && left < right) left++;
	            if (left < right) {
	                // 交换左右两边的值
	                int temp = a[left];
	                a[left] = a[right];
	                a[right] = temp;
	            }
	        }
	        // 归位基准值
	        a[start] = a[left];
	        a[left] = pivot;
	        return left;
	    }
		解法二：填坑法
		public static void quickSort(int[] arr, int start, int end) {
	        // 分治思想，选取一个基准值，每次将数组分成两区，左边全部小于基准值，右边全部大于基准值。
	        if (start >= end) {
	            return;
	        }
	        int mid = partitionFillPit(arr, start, end);
	        quickSort(arr, start, mid - 1);
	        quickSort(arr, mid + 1, end);
	    }
	    
	    public static int partition(int[] a, int start, int end) {
	        // 将第一个元素作为基准值（第一个坑位）
	        int pivot = a[start];
	        while (start < end) {
	            while (a[end] >= pivot && start < end) end--;
	            // 将小于基准值的元素填入先前的坑位，并将此元素的位置作为新的坑位
	            a[start] = a[end];
	            while (a[start] <= pivot && start < end) start++;
	            // 将大于基准值的元素填入先前的坑位，并将此元素的位置作为新的坑位
	            a[end] = a[start];
	        }
	        //归位基准值
	        a[start] = pivot;
	        return start;
	    }
3. 单例

		1. 饿汉式单例
		public class Singleton {
			private static Singleton sInstance = new Singleton();
			private Singleton() {}
			public static Singleton getInstance() {
				return sInstance;
			}
	
		}
		//类加载的时候进行初始化，基于类加载机制避免了多线程问题。缺点：初始化慢。
		2. 懒汉式线程不安全单例
		public class Singleton {
			private static Single sInstance;
			private Singleton() {}
			public static Singleton getInstance() {
				if (sInstance == null) {
					sInstance = new Singleton();
				}
				return sInstance;
			}
		
		}
		// 类调用时候进行初始化，节约资源。 缺点： 线程不安全。
		3. 懒汉式synchronized单例
		public class Singleton {
			private static Singleton sInstance;
			private Singleton(){}
			public static synchronized Singleton getInstance() {
				if (sInstance == null) {
					sInstance = new Singleton();
				}
				return sInstance;
			}
		}
		// 类调用时候进行初始化，节约资源， 线程安全。 缺点：每次调用getInstance都需要进行线程同步，造成不必要的同步开销。
		4. 懒汉式双重检验锁单例
		public class Singleton {
			// 使用volatile 保证内存的可见性和禁止JVM指令重排
			private volatile static Singleton sInstance;
			private Singleton() {}
			public static Singleton getInstance() {
				// 避免不必要的同步
				if (sInstance == null) {
					// 第一次创建时同步
					synchronized(Singleton.class) {
						if (sInstance == null) {
							sInstance = new Singleton();
						}
					}
				}
				return sInstance;
			}

		}
		// 类调用时候进行初始化，节约资源，线程安全， 避免了synchronized不必要的同步开销。缺点： 在高并发的情况，存在一定概率失效的问题。
		5. 静态内部类单例
		public class Singleton {
			private static class SingletonHolder {
				private static final Singleton INSTANCE = new Singleton();
			}
			private Singleton () {}
			public static Singleton getInstance() {
				return SingletonHolder.INSTANCE;
			} 
		}
		// 类调用getInstance才会在虚拟机中进行SingletonHolder的初始化， 保证了线程安全和唯一性。 缺点：对象反序列化时会重新创建一个新的对象。
		6. 枚举单例
		public enum Singleton {
			INSTANCE;
		}
		// 简单， 枚举默认是线程安全，同时能防止对象反序列化时重新创建对象。 缺点： 可读性不高。


4. 双链表实现

    	// 结点结构
    	private class Node<E> {
    		E item;
    		Node<E> prev;
    		Node<E> next;
    		
    		public Node(Node<E> prev, E item, Node<E> next) {
    			this.prev = prev;
    			this.item = item;
    			this.next = next;
    		}
    	}
    	
    	// 使用first, last, size记录头结点，尾结点，和节点数量。
    	int size
		Node<E> first;
		Node<E> last;
		// 插入一个元素到链表尾部
		void linkLast(E e) {
			Node<E> l = last;
			Node<E> newNode = new Node<>(l, e, null);
			// 更新尾结点为新建结点
			last = newNode;
			// 链表为null,头结点指向新建结点。否则上一个尾结点的下一个结点指向新建结点。
			if (l == null) {
				first = newNode;
			} else {
				l.next = newNode;
			}
			//结点数量加1
			size++;

		}
		// 插入一个元素到链表头部
		void linkFirst(E e) {
			Node<E> f = first;
			Node<E> newNode = new Node<>(null, e, f);
			// 更新头结点为新建结点
			first = newNode;
			// 链表为null,尾结点指向新建结点。否则上一个头结点的上一个结点指向新建结点。
			if (f == null) {
				last = newNode;
			} else {
				f.prev = newNode;
			}
			//结点数量加1
			size++;

		}
		// 查找指定下标结点
		Node<E> node(int index) {
			// 如果要查找的小标存在于链表的前半部分。从前往后查找，否则从后往前查找。
			if (index < (size >> 1)) {
				Node<E> x = first;
				for (int i = 0; i < index; i++) {
					x = x.next;
				}
				return x;
			} else {
				Node<E> x = last;
				for(int i = size - 1; i > index; i--) {
					x = x.prev;
				}
				return x;
			}		
		}
		// 在指定下标插入元素
		void add(int index, E element) {
			if (index == size) {
				linkLast(element);
			} else {
				linkBefore(element, node(index));
			}
			
		}
		//在指定结点succ前插入元素
		void linkBefore(E element, Node<E> succ) {
			Node<E> pred = succ.prev;
			// 构建新结点。结点的前继和后继指向succ的前继和succ
			Node<E> newNode = newNode<>(pred, element, succ);
			// succ的前继指向新结点
			succ.prev = newNode;
			// 如果succ是头结点，则头结点指向新建结点。否则succ前继结点的后继指向新建结点。
			if (pred == null) {
				first = newNode;
			} else {
				pred.next = newNode;
			}
			size++;
		}
		//删除头结点
		E unlinkFirst(Node<E> f) {
			assert f == first && f != null;
			// 删除结点元素。
			final E element = f.item;
			// 头结点的下一个结点
			Node<E> next = f.next;
			// help gc
			f.item = null;
			f.next = null;
			// 头结点变成下一个结点。
			first = next;
			// 链表为null,尾结点置null。否则头结点的前继置null。
			if (next == null) {
				last = null;
			} else {
				next.prev = null;
			}
			size--;
			return element;
			
		}
		// 删除尾结点
		E unlinkLast(Node<E> l) {
			assert l == last && l != null;
			final E element = l.item;
			// 尾结点的前一个结点
			final Node<E> prev = l.prev;
			// help gc.
			l.item = null;
			l.prev = null;
			// 尾结点变成前一个结点。
			last = prev;
			// 链表为null,头结点置null。否则尾结点的后继置null。
			if (prev == null) {
				first = null;
			} else {
				prev.next = null;
			}
			size--;
			return element;
		}
		// 删除指定结点
		E unlink(Node<E> x) {
			assert x != null;
			final E element = x.item;
			// 删除结点前继和后继节点
			Node<E> pred = x.prev;
			Node<E> succ = x.next;
			// help gc.
			x.item = null;
			x.prev = null;
			x.next = null;
			// 如果删除的结点是头结点，则头结点设置成后继节点。否则前继结点的后继指向后继结点。
			if (pred == null) {
				first = succ;
			} else {
				pred.next = succ;
			}
			// 如果删除的结点是尾结点，则尾结点设置成前继节点。否则后继结点的前继指向前继结点。
			if (succ == null) {
				last = pred;
			} else {
				succ.prev = pred;
			}
			size--;
			return element;
		}

5. HashMap（JDK1.7）

        // HashMap是基于Hash表的Map实现，提供所有可选的键值映射操作。底层实现是数组单链表实现。
        // 单链表结点结构, 实现Map.Entry接口来操作Map键值对
        static class Entry<K, V> implements Map.Entry<K, V> {
            final K key;
            V value;
            Entry<K, V> next;
            int hash;//对输入对象进行hash函数生成，相同的对象只会生成相同的hash值, 不同的对象可能生成相同的hash值（碰撞或者冲突）。

            Entry(int h, K k, V v, Entry<K,V> n) {
                value = v;
                next = n;
                key = k;
                hash = h;
            }
        }
        // 结点数组
        transient Entry<K,V>[] table;
        // 数组大小
        transient int size;
        // 阈值。等于size * loadFactor;
        int threshold;
        // 加载因子, 衡量HashMap满的指标, 默认0.75。
        final float loadFactor;

        // 添加键值对
        public V put(K key, V value) {
            if (key == null)
                return putForNullKey(value);
            // 计算key的hash值
            int hash = hash(key);
            // 通过hash值计算出table下标
            int i = indexFor(hash, table.length);
            for(Entry<K, V> e = table[i]; e != null; e = e.next) {
                Object k;
                // 结点已存在值，覆盖并返回旧值
                if (e.hash == hash && ((k = e.key) == key) || e.value == value) {
                    V oldValue = e.value;
                    e.value = value;
                    e.recordAccess(this);
                    return oldValue;
                }
            }

            modCount++;
            // 添加键值对到结点数组中
            addEntry(hash, key, value, i);
            return null;
        }

        final int hash(Object k) {
            int h = 0;
            if (useAltHashing) {
                if (k instanceof String) {
                    return sun.misc.Hashing.stringHash32((String) k);
                }
                h = hashSeed;
            }

            h ^= k.hashCode();

            // This function ensures that hashCodes that differ only by
            // constant multiples at each bit position have a bounded
            // number of collisions (approximately 8 at default load factor).
            h ^= (h >>> 20) ^ (h >>> 12);
            return h ^ (h >>> 7) ^ (h >>> 4);
        }

        /**
         * Returns index for hash code h.
         */
        static int indexFor(int h, int length) {
            return h & (length-1);
        }

        void addEntry(int hash, K key, V value, int bucketIndex) {
            // 数组大小超过threshold, 哈希表进行rehash操作(原来数组大小扩展成两倍，将原有数组数据复制到新建数组)。
            if ((size >= threshold) && (null != table[bucketIndex])) {
                resize(2 * table.length);
                // 重新计算hash值和数组下标
                hash = (null != key) ? hash(key) : 0;
                bucketIndex = indexFor(hash, table.length);
            }
            // 插入键值对到数组链表中
            createEntry(hash, key, value, bucketIndex);
        }

        void createEntry(int hash, K key, V value, int bucketIndex) {
            Entry<K,V> e = table[bucketIndex];
            // 新建Entry结点，插入到单链表头部。
            table[bucketIndex] = new Entry<K,V>(hash, key, value, e);
            size++;
        }
        // rehash
        void resize(int newCapacity) {
            Entry[] oldTable = table;
            int oldCapacity = oldTable.length;
            // 如果数组超过最大容量不扩容直接返回
            if (oldCapacity == MAXIMUM_CAPACITY) {
                threshold = Integer.MAX_VALUE;
                return;
            }
            // 新建数组，大小为原来数组大小的两倍
            Entry[] newTable = new Entry[newCapacity];
            boolean oldAltHashing = useAltHashing;
            useAltHashing |= sun.misc.VM.isBooted() &&
                    (newCapacity >= Holder.ALTERNATIVE_HASHING_THRESHOLD);
            boolean rehash = oldAltHashing ^ useAltHashing;
            // 将老的数组数据复制到新的数组中
            transfer(newTable, rehash);
            // 重新设置table和threshold
            table = newTable;
            threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);
        }
        void transfer(Entry[] newTable, boolean rehash) {
            int newCapacity = newTable.length;
            // 遍历数组每个结点
            for (Entry<K,V> e : table) {
                // 遍历每个结点链表
                while(null != e) {
                    // 记录下一个几点
                    Entry<K,V> next = e.next;
                    if (rehash) {
                        e.hash = null == e.key ? 0 : hash(e.key);
                    }
                    // 计算key值在新数组的下标
                    int i = indexFor(e.hash, newCapacity);
                    // https://coolshell.cn/articles/9606.html
                    // 将老的数组下标结点链表数据反向插入到新数组下标结点。这个操作可能导致在多线程环境下导致回环链表。
                    // to[i] = e->f->null;
                    // t[i] = e->null
                    // f->e->null;
                    // t[i] = f->e->null
                    e.next = newTable[i];
                    newTable[i] = e;
                    e = next;
                }
            }
        }
        // 通过键获取值
        public V get(Object key) {
            if (key == null)
                return getForNullKey();
            Entry<K,V> entry = getEntry(key);

            return null == entry ? null : entry.getValue();
        }
        final Entry<K,V> getEntry(Object key) {
            // 获取key进行hash得到hash值
            int hash = (key == null) ? 0 : hash(key);
            // 根据hash值得到数组下标。对数组下标结点链表进行遍历
            for (Entry<K,V> e = table[indexFor(hash, table.length)];
                 e != null;
                 e = e.next) {
                Object k;
                if (e.hash == hash &&
                    ((k = e.key) == key || (key != null && key.equals(k))))
                    return e;
            }
            return null;
        }
        // 根据键删除键值对
        public V remove(Object key) {
            Entry<K,V> e = removeEntryForKey(key);
            return (e == null ? null : e.value);
        }

        final Entry<K,V> removeEntryForKey(Object key) {
            int hash = (key == null) ? 0 : hash(key);
            int i = indexFor(hash, table.length);
            Entry<K,V> prev = table[i];
            Entry<K,V> e = prev;
            // 遍历链表
            while (e != null) {
                Entry<K,V> next = e.next;
                Object k;
                if (e.hash == hash &&
                    ((k = e.key) == key || (key != null && key.equals(k)))) {
                    modCount++;
                    size--;
                    // 要删除的结点是第一个结点
                    if (prev == e)
                        table[i] = next;
                    else
                    // 要删除结点的前驱的后继链接删除结点的下一个结点
                        prev.next = next;
                    e.recordRemoval(this);
                    // 返回删除元素结点
                    return e;
                }
                prev = e;
                e = next;
            }

            return e;
        }

6. HashSet(JDK1.7)

	
		
		//HashSet基于Hash表的Set实现集合。Set定义了无重复元素且没有顺序的容器接口。
		//内部是通过HashMap实例来进行实现。
		
		private transient HashMap<E,Object> map;
		
		// Dummy value to associate with an Object in the backing Map
		private static final Object PRESENT = new Object();
		   // 构造函数初始化map实例
		   	public HashSet(int initialCapacity, float loadFactor) {
		map = new HashMap<>(initialCapacity, loadFactor);
		}
		// 添加元素
		   public boolean add(E e) {
		   // 如果元素不存在返回null,否则返回旧值也就是PRESENT虚拟值。
		   return map.put(e, PRESENT)==null;
		   }
		   // 删除元素
		   public boolean remove(Object o) {
		   // 如果Set集合中不存在此元素，返回null,否则返回删除元素旧值也就是PRESENT。
		   return map.remove(o)==PRESENT;
		   }


7. 树
		
		
		  // https://www.jianshu.com/p/b378864bb8fc
		  树是有现实中的树抽象而来的，表示具有N个有父子关系节点的有限集合。这个有限集合需要满足以下条件：
		  1. N = 0，该集合为空，表示一个空树。
		  2. N > 0, 尤其只有一个根节点(root).
		  3. N > 1, 跟节点以外的节点可分为M个互为相交的子集合T1,T2...TM, 每一个子集合又是一颗树， 称为根节点的子树。
		  按根节点是否包含子节点，可把树的节点分为：
		  1. 普通节点：包含子节点的节点。
		  2. 叶子节点：不包含子节点的节点。
		  按节点是否有父节点， 可把树的节点分为：
		  1. 根节点：没有父节点的节点。
		  2. 普通节点：有父节点的节点。
		
		  树相关的术语：
		  1.节点： 树的最基本组成单元， 通常包括一个数据元素及若干指针用于指向其他节点。
		  2.节点的度：节点拥有的子孙的个数被称为节点的度。
		  3.树的度：树中所有节点的度的最大值就是该树的度。
		  4.叶子节点：度为0的节点被称为叶子节点或终端节点。
		  5.分支节点：度不为0的节点被称为分支节点或非终端节点。
		  6.子节点，父节点，兄弟节点：节点的子树的根被称为该节点的子节点，而该节点称为子节点的父节点(parent).具有相同父节点的子节点之间互称为兄弟节点。
		  7.节点的层次(level):节点的层次从根开始算起，根的层次值为1，其余节点的层次值为父节点层次值加l。
		  8.树的深度(depth):树中节点的最大层次值称为树的深度或高度。
		  9.有序树与无序树:如果将树中节点的各棵子树看成从左到右是有序的(即不能互换),则称该树为有序树,否则称为无序树。
		  10.祖先节点(ancestor)：从根到该节点所经分支上的所有节点
		  11.后代节点(descendant):以某节点为根的子树中任一节点都称为该节点的后代节点。
		  12.森林(forest):森林是；两颗或两颗以上互不相交的树的集合，删去一棵树的根，就得到一个森林。
		
		  二叉树
		  1.二叉树指的是每个节点最多只能有两个子树的有序树。通常左边的子树被称作“左子树”(left subtree)，右边的子树被称为“右子树”(right subtree).
		  3.一棵深度为k的二叉树，如果它包含了2^k-1个节点，这颗二叉树称为满二叉树。
		  4.如果一颗二叉树除最后一层外，其余层的所有节点都是满的，并且最后一层或者是满的，或者仅在右边缺少若干连续的节点，则此二叉树就是完全二叉树。
		  遍历：
		  前序遍历（DLR），中序遍历（LDR），后序遍历(LRD)。深度优先遍历(DFS)，广度优先（层次）遍历(队列实现)。
		  非递归遍历：
		  从最左边第一个节点开始，依次找后继节点。给定一个节点，找其后继节点的算法为：
		  如果该节点有右孩子，则后继节点为右孩子中最小的节点。
		  如果该节点没有右孩子，则后继节点为父节点或者某个祖先节点，从当前节点往上找，如果它是父亲节点的右孩子，则继续找父节点，直到它不是右孩子或父节点为空。
		  第一个非右孩子节点的父节点就是后继节点，如果找不到这样的祖先节点，则后继节点为空，遍历结束。
		  插入：
		  从根节点往下查找
		  与当前节点比较，如果相同，表示已经存在了，不能再插入。
		  如果小于当前节点，则到左子树中寻找，如果左子树为空，则当前节点即为要找的父节点。
		  如果大于当前节点，则到右子树中寻找，如果右子树为空，则当前节点即为要找的父节点。
		  找到父节点后，即可插入，如果插入元素小于父节点，则作为左孩子插入，否则作为右孩子插入。
		
		  删除：
		  从排序二叉树中删除一个节点要复杂一些，有三种情况：
		  节点为叶子节点，直接删除。
		  节点只有一个孩子，让待删节点的父节点和子节点进行链接。
		  节点有两个孩子， 找到待删节点的的后继节点（根据之前介绍的后继算法，后继为右子树中最小的节点，这个后继一定没有左孩子），
		  找到后继后，替换待删节点为后继的内容，然后再删除后继节点。后继节点没有左孩子，这就将两个孩子的情况转换为了叶子节点或只有一个孩子的情况。
		
		  旋转：
		  树旋转（英语：Tree rotation）是对二叉树的一种操作，不影响元素的顺序（中序遍历），但会改变树的结构，将一个节点上移、一个节点下移。树旋转会改变树的形状，因此常被用来将较小的子树下移、较大的子树上移，从而降低树的高度、提升许多树操作的效率。
		  左旋转：左孩子旋转到父节点的位置为右旋。
		  右旋转：右孩子旋转到父节点的位置为左旋。
		  假设两颗树的中序遍历为：X:((A,P,B),Q,C)和Y:(A,P,(B,Q,C))。X右旋可以得到Y，Y左旋可以得到X。
		  左旋：
		  设P为Q的左子树。
		  将Q的右子树设为P的右子树。
		  将P的右子树设为Q。
		  右旋：
	 	  设Q为P的右子树。
		  将Q的左子树设为P的右子树。
		  将Q的左子树设为P。
		  上述树旋转没有考虑到父节点，但是实际构造二叉树的是存在父节点，其节点结构一般为：
			static class Node<T> {
			T date;
			Node left;
			Node right;
			Node parent;
			}
			Node<R> root;
			void rotateLeft(Node<T> p) {
			assert p != null;
			// 设r为旋转节点，p为父节点
			Node<T> r = p.right;
			// L0:设置旋转节点左孩子和父节点右孩子链接。
			// L0-0:将旋转节点左孩子设为父节右孩子。
			p.right = r.left;
			// L0-1:将旋转节点左孩子的父节点设为旋转节点的父节点。
			if (r.left != null) r.left.parent = p;
			// L1:设置旋转节点和爷爷节点（父节点的父节点）链接。
			// L1-0:将旋转节点的父节点孩子设为爷爷节点（父节点的父节点）。
			r.parent = p.parent;
			// L1-1:
			1. 如果爷爷节点为null，则父节点是根节点，设置根节点为旋转节点。
			2. 如果父节点是爷爷节点的右孩子，将爷爷节点的右孩子设为旋转节点。
			3. 如果父节点是爷爷节点的左孩子，将爷爷节点的左孩子设为旋转节点。
			if (p.parent == null) {
			root = r;
			} else if (p.parent.right == p) {
			p.parent.right = r;
			} else {
			p.parent.left = r;
			}
			// L2:设置旋转节点和父节点链接。
			// L2-0: 将旋转节点设为父节点的父亲。
			p.parent = r;
			// L2-1: 将父节点设为旋转节点的左孩子。
			r.left = p;
			}
			void rotateRight(Node<T> p) {
			assert p != null;
			// 设l为旋转节点，p为父节点。
			Node<T> l = p.left;
			// L0:设置旋转节点右孩子和父节点左孩子链接。
			// L0-0:将旋转节点右孩子设为父节点左孩子。
			p.left = l.right;
			// L0-1:将旋转节点右孩子的父节点设为旋转节点的父节点。
			if (l.right != null) l.right.parent = p;
			// L1:设置旋转节点和爷爷节点（父节点的父节点）链接。
			// L1-0:将旋转节点的父节点孩子设为爷爷节点（父节点的父节点）。
			l.parent = p.parent;
			// L1-1:
			1. 如果爷爷节点为null，则父节点是根节点，设置根节点为旋转节点。
			2. 如果父节点是爷爷节点的右孩子，将爷爷节点的右孩子设为旋转节点。
			3. 如果父节点是爷爷节点的左孩子，将爷爷节点的左孩子设为旋转节点。
			if (p.parent == null) {
			root = l;
			} else if (p.parent.right == p) {
			p.parent.right = l;
			} else {
			p.parent.left = l;
			}
			// L2:设置旋转节点和父节点链接。
			// L2-0: 将旋转节点设为父节点的父亲。
			p.parent = l;
			// L2-1: 将父节点设为旋转节点的右孩子。
			l.right = p;
			}
		
		  AVL树：
		  AVL树是自平衡的二叉查找树。在AVL树中任何节点的两个子树的高度最大差别为1，所以它也被称为高度平衡树。
		  1.本身首先是一棵二叉搜索树。
		  2.带有平衡条件：每个结点的左右子树的高度之差的绝对值（平衡因子）最多为1。
		   AVL树在查找、插入和删除在平均和最坏情况下的时间复杂度都是O(logn),增加和删除元素的操作则可能需要借由一次或多次树旋转以实现树的重新平衡。
		
		 遍历：
		  跟普通二叉查找树遍历一样，耗费O(log n)时间。
		
		 插入：
		 1. 左左型：右旋。
		 2. 右右型：左旋。
		 3. 左右型：左旋右旋。
		 4. 右左型：右旋左旋。
		
		 左左型：
		     X
		    /
		   Y ->  Y
		  /    /   \
		 Z    Z     X
		 右右型：
	     X
		  \
		   Y  ->   Y
		    \    /   \
		     Z  X     Z
		
		左右型：
		   X     X
		  /     /
		Y ->   Z  ->   Z
		 \    /      /  \
		  Z  Y      Y    X
		右左型：
		   X   X
			\	\
		 	Y -> Z   ->   Z
		   /	  \     /   \
		  Z   	   Y   X     Y
		删除：
		通过把要删除的节点向下旋转成一个叶子节点，接着直接移除这个叶子节点来完成。因为在旋转成叶子节点期间最多有log n个节点被旋转，而每次AVL旋转耗费固定的时间，所以删除处理在整体上耗费O(log n) 时间。
		
		红黑树：
		红黑树是每个结点都带有颜色属性的二叉查找树，颜色为红色或者黑色。是一种自平衡二叉查找树，在满足二叉查找的的所有特性情况下，具有如下的性质：
		1. 节点是红色或者黑色。
		2. 根是黑色。
		3. 所有叶子节点是黑色（叶子是NIL节点）。
		4. 每个红色节点必须有两个黑色子节点（从每个叶子节点到根所有路径上不能有两个连续的红色节点）。
		5. 从任一节点到其每个叶子节点的所有简单路径都包含相同数目的黑色节点。
		   红黑树的这些特性保证了从根到叶子的最长可能路径不多于从根到叶子的最短可能路径的两倍长，因此相对于AVL树，牺牲了部分平衡性换取了插入和删除时的少量旋转操作，整体来说性能优于AVL树。
		插入：
		1. 将红黑树当作一颗二叉查找树，将节点插入。
		2. 将插入的节点着色为红色。
		3. 经过一些列的变色和旋转重新修正红黑树，使得它满足以上性质。
		删除：
		1. 将红黑树当作一颗二叉查找树，将节点删除。
		2. 通过"旋转和重新着色"等一系列操作来修正该树，使之重新成为一棵红黑树。

8. TreeMap(JDK1.7)



	    TreeMap是键值对按键有序，为了实现Key有序，要求Key实现Comparable接口或者构造时传入Comparator以此来保证Key的顺序。
	    相对于HashMap实现Map接口，TreeMap还实现了SortedMap和NavigationMap来保证Key的有序性和一些lowerXX,floorXX,ceilingXX,higherXX等导航方法来方便TreeMap操作。
	    TreeMap底层实现是红黑树：
    	   // 节点结构
	       static final class TreeMapEntry<K,V> implements Map.Entry<K,V> {
		       K key;
		       V value;
		       TreeMapEntry<K,V> left;
		       TreeMapEntry<K,V> right;
		       TreeMapEntry<K,V> parent;
		       boolean color = BLACK;
		    
		       TreeMapEntry(K key, V value, TreeMapEntry<K,V> parent) {
		       this.key = key;
		       this.value = value;
		       this.parent = parent;
		       }
	       }
        // 成员数据
        // 比较器，构造函数出入。
        private final Comparator<? super K> comparator;
        // 红黑树根节点。
        private transient TreeMapEntry<K,V> root;
        // 树的节点数量。
        private transient int size = 0;
        // 以下代码只涉及核心逻辑，判断和其他其余条件都去除了。
        // 插入
        public V put(K key, V value) {
            TreeMapEntry<K,V> t == root;
            if (t == null) {
                root = new TreeMapEntry(key, value, null);
                size++;
                return null;
            }
            int cmp;
            TreeMapEntry<K,V> parent;
            // L0: 遍历查找插入节点的父节点。
            do {
                parent = t;
                // 假定使用的是comparator
                cmp = comparator.compare(key, t.key);
                if (cmp < 0) {
                    // 小于父节点，左子树查找。
                    t = t.left;
                } else if (cmp > 0) {
                    // 大于父节点，右子树查找。
                    t = t.right;
                } else {
                    // 已经存在替换旧值。
                    return t.setValue(key, value);
                }
            } while (t != null);
            // L1: 将新节点插入二叉树中
            // 构建新结点
            TreeMapEntry<K,V> e = new TreeMapEntry<K,V>(key, value, parent);
            if (cmp < 0) {
                // 小于父节点，插入到父节点的左边
                parent.left = e;
            } else {
                // 大于父节点，插入到父节点的右边
                parent.right = e;
            }
            // L2: 重新着色和旋转修正红黑树。
            fixAfterInsertion(e);
            size++;
            return null;
        }
        // 删除
        public V remove(Object key) {
            // 遍历查找key相关的节点。
            TreeMapEntry<K,V> p = getEntry(key);
            if (p == null)
                return null;
            // 删除key相关的节点，并返回原来的值。
            V oldValue = p.value;
            deleteEntry(p);
            return oldValue;
        }
        final TreeMapEntry<K,V> getEntry(Object key) {
            TreeMapEntry<K,V> p = root;
            int cmp;
            while (p != null) {
                cmp = comparator.compare(key, p.key)
                if (cmp < 0) {
                    p = p.left;
                } else if (cmp > 0) {
                    p = p.right;
                } else {
                    return p;
                }
            }
            return null;
        }
        private void deleteEntry(TreeMapEntry<K,V> p) {
            size--;
            // L0:两个节点情况：如果删除节点有左右孩子，则将删除结点的后继节点替换删除结点,转化成删除节点只有一个子孩子或者没有孩子的情况。
            if (p.left != null && p.right != null) {
                TreeMapEntry<K,V> s = successor(p);
                p.key = s.key;
                p.value = s.value;
                p = s;
            }
            TreeMapEntry<K,V> replacement = p.left != null ? p.left : p.right;
            // L1: 一个节点情况, 将待删节点的父节点和其孩子进行链接。
            if (replacement != null) {
                if (p.parent == null) {
                    // 删除的节点是根节点
                    root = replacement;
                } else if (p == p.parent.left) {
                    // 删除的节点是父节点的左孩子
                    p.parent.left = replacement;
                } else {
                    // 删除的节点是父节点的右孩子
                    p.parent.right = replacement;
                }
                // 删除节点置null.
                p.left = p.right = p.parent = null;
                // 删除节点的颜色是黑色，破坏了红黑树第五条特性，重新着色或者旋转进行修正。
                if (p.color == BLACK) {
                    fixAfterDeletion(replacement);
                }
            } else if (p.parent == null) {
            // L2: 根节点情况
                // 只有一个节点情况。
                root == null;
            } else {
            // L3: 叶子节点情况
                // 删除的是叶子节点的情况，破坏了红黑树第五条特性，重新着色或者旋转进行修正。
                if (p.color == BLACK) {
                    fixAfterDeletion(p);
                }

                if (p.parent != null) {
                    if (p == p.parent.left) {
                        // 左叶子节点
                        p.parent.left = null;
                    } else if (p == p.parent.right) {
                        // 右叶子节点
                        p.parent.right = null;
                    }
                    // 将待删节点的父节点置null。
                    p.parent = null;
                }
            }

        }
        // 查找一个节点的后继节点（如果这个节点有右子树，则后继节点是右子树中最小的节点，否则是第一个非右孩子节点的父节点）。
        static <K,V> TreeMapEntry<K,V> successor(TreeMapEntry<K,V> t) {
            if (t == null)
                return null;
            // 如果右子树中存在左子树，在最小节点一定存在于右子树的左子树中，如果不存在左子树，则最小节点是右子树的第一个右孩子。
            if (t.right != null) {
                TreeMapEntry<K,V> p = t.right;
                while (p.left != null) {
                    p = p.left;
                }
                return p;
            }
            // 不存在右子树，则后继节点是第一个非右孩子的父节点。
            if (t.parent != null) {
                TreeMapEntry<K,V> p = t.parent;
                TreeMapEntry<K,V> ch = t;
                while (p != null && ch == p.right) {
                    ch = p;
                    p = p.parent;
                }
                return p;
            }

        }

9. TreeSet(JDK1.7)

        TreeSet是基于TreeMap的NavigationSet实现。
        //内部实现
        // 内部通过TreeMap实例进行操作
        private transient NavigableMap<E,Object> m;
        // 虚拟值
        private static final Object PRESENT = new Object();
        TreeSet(NavigableMap<E,Object> m) {
              this.m = m;
        }
        // 添加
        public boolean add(E e) {
            return m.put(e, PRESENT)==null;
        }
        // 删除
        public boolean remove(Object o) {
            return m.remove(o)==PRESENT;
        }

10. 堆

        堆一种特别的树状数据结构。若是满足以下特性，即可称为堆：“给定堆中任意节点P和C，若P是C的母节点，那么P的值会小于等于（或大于等于）C的值”。若母节点的值恒小于等于子节点的值，此堆称为最小堆（min heap）；反之，若母节点的值恒大于等于子节点的值，此堆称为最大堆（max heap）。在堆中最顶端的那一个节点，称作根节点（root node），根节点本身没有母节点（parent node）。
        二叉堆
            二叉堆是一种特殊的堆，是完全二叉树，二叉堆满足堆特性：父节点的键值总是保持固定的序关系于任何一个子节点的键值，且每个节点的左子树和右子树都是一个二叉堆。
            当父节点的键值总是大于或等于任何一个子节点的键值时为“最大堆”。当父节点的键值总是小于或等于任何一个子节点的键值时为“最小堆”。
            当给一颗完全二叉树按层次进行编号时，它们的父子顺序总是保持的一种隐式的连接。假设父节点的编号时k,则两个子节点的编号是2k和2k+1。因为这种关系，一般二叉堆使用数组进行存储，以方便高效的访问。
        // 以下以最小堆说明添加，删除，构造二叉堆的过程。
        添加元素
            1.添加元素到最后位置。
            2.与父节点比较，如果大于等于父节点，则满足堆性质，结束，否则与父节点进行交换，然后继续与父节点进行比较交换直到父节点为空或者大于等于父节点（上滤(siftup)）。
        删除元素
            头部删除：
                1.用最后一个元素替换掉头部元素，并删除最后一个元素。
                2.将新的头部与两个孩子节点中较小的比较，如果小于孩子节点，满足堆性质，结束，否则与较小的孩子进行交换，交换后继续与其孩子进行交换比较直到没有孩子节点或者小于孩子节点（下滤(siftdown)）。
            中间删除：
                1.用最后一个元素替换掉要删除元素，并删除最后一个元素。
                2.将新的元素与子孩子进行比较，如果大于孩子节点进行下滤(siftdown)操作，否则进行上滤(siftup)操作。

        构建二叉堆
            将无序数组变成堆的过程称为heapify，从最后一个非叶子节点开始，一直往前直到根，对每个节点，执行向下调整siftdown。
            换句话说，是自底向上，先使每个最小子树为堆，然后每对左右子树和其父节点合并，调整为更大的堆，因为每个子树已经为堆，所以调整就是对父节点执行siftdown，就这样一直合并调整直到根。
        查找和遍历
            从数组的头到数组的尾进行查找，效率O(N)。


11. PriorityQueue(JDK1.7)


	        一个基于最小二叉堆的无界优先级队列，优先级队列元素通过实现Comparable或者构造传入Comparator来保证元素有序。
	        // 实现原理,以下代码只涉及到核心逻辑，删除了不必要的条件判断。
	        // 内部成员
	        transient Object[] queue;
	        int size;
	        private final Comparator<? super E> comparator;
	        // 构造函数
	        public PriorityQueue(int initialCapacity,
	                             Comparator<? super E> comparator) {
	            // Note: This restriction of at least one is not actually needed,
	            // but continues for 1.5 compatibility
	            if (initialCapacity < 1)
	                throw new IllegalArgumentException();
	            this.queue = new Object[initialCapacity];
	            this.comparator = comparator;
	        }
	        // 添加元素
	        public boolean offer(E e) {
	            int i = size;
	            // 如果优先级队列元素超过数组大小进行扩容
	            if (i >= queue.length)
	                grow(i + 1);
	            // 元素数量加一
	            size = i + 1;
	            // 队列为空
	            if (i == 0) {
	                queue[i] = e;
	            } else {
	                // 从队列尾部开始执行上滤(siftup)操作
	                siftUp(i, e);
	            }
	            return true;
	        }
	        // 上滤操作
	        private void siftUp(int k, E x) {
	            if (comparator != null)
	                siftUpUsingComparator(k, x);
	            else
	                siftUpComparable(k, x);
	        }
	        private void siftUpUsingComparator(int k, E x) {
	            // 从后往前进行比较替换，直到插入元素x大于等于父节点
	            while (k > 0) {
	                // 父节点元素下标
	                int parent = (k - 1) >>> 1;
	                Object e = queue[parent];
	                if (comparator.compare(x, (E)e) >= 0)
	                    break;
	                // 将父节点下移，k设为父节点下标，继续往上查找
	                queue[k] = e;
	                k = parent;
	            }
	            // 更新元素
	            queue[k] = x;
	        }
	        // 头部删除
	        public E poll() {
	            // 队列为空，返回null
	            if (size == 0)
	                return null;
	            // 删除最后一个元素
	            int s = --size;
	            E result = (E) queue[0];
	            E x = (E) queue[s];
	            queue[s] = null;
	            // 从队列头部开始执行下滤(siftdown)操作
	            if (s != 0)
	                siftDown(0, x);
	            // 返回删除的头部节点元素
	            return result;
	        }
	        // 下滤操作
	        private void siftDown(int k, E x) {
	            if (comparator != null)
	                siftDownUsingComparator(k, x);
	            else
	                siftDownComparable(k, x);
	        }
	        private void siftDownUsingComparator(int k, E x) {
	            // 从根节点到最后一个非叶子节点进行查找替换
	            int half = size >>> 1;
	            while (k < half) {
	                // 左孩子节点下标
	                int child = (k << 1) + 1;
	                // 假设左孩子节点是孩子节点中较小的孩子
	                Object c = queue[child];
	                // 右孩子节点下标
	                int right = child + 1;
	                // 如果右孩子小于左孩子，更新孩子节点的最小值和下标
	                if (right < size && comparator.compare(c, (E)queue[right]) >= 0) {
	                    c = queue[child = right];
	                }
	                // 如果父节点小于等于孩子节点，满足堆性质，退出循环
	                if (comparator.compare(x, (E)c) <= 0)
	                    break;
	                // 将较小的孩子节点进行上移，k设为较小孩子节点的下标，继续往下查找
	                queue[k] = c;
	                k = child;
	            }
	            // 更新元素
	            queue[k] = x;
	        }
	        // 删除指定位置的元素
	        E removeAt(int i) {
	            int s = --size;
	            // 删除最后一个元素
	            if (s == i) {
	                queue[i] = null;
	            } else {
	                // 删除最后一个元素
	                E moved = (E) queue[s];
	                queue[s] = null;
	                // 先执行下滤
	                siftDown(i, moved);
	                // 如果下滤不成功，说明需要上滤
	                if (queue[i] == moved) {
	                    siftUp(i, moved);
	                    // 上滤成功返回moved值
	                    if (queue[i] != moved)
	                        return moved;
	                }
	            }
	        }
	        // 查找元素下标
	        private int indexOf(Object o) {
	            if (o != null) {
	                for (int i = 0; i < size; i++)
	                    if (o.equals(queue[i]))
	                        return i;
	            }
	            return -1;
	        }


12. ArrayDeque


	    循环数组: 如果数组最后一个元素的下一个元素是数组第一个元素，那么这个数组就是循环数组。
	    获取数组下一个下标：通过下一个数组下标和数组长度取模可取得下标位置。
	    为了用循环数组高效的实现Deque，ArrayDeque使用了两个变量指针head,tail来指向数组的第一个和最后一个元素，方便高效的操作队列的头和尾。
	    1. 如果head和tail相同，则数组为空，长度为0。
	    2. 如果tail大于head，则第一个元素为elements[head]，最后一个为elements[tail-1]，长度为tail-head，元素索引从head到tail-1。
	    3. 如果tail小于head且为0，则第一个元素为elements[head]，最后一个元素elements[elements.length-1],长度为elements.length-head, 元素索引从head到elements.length-1。
	    4. 如果tail小于head且大于0，则会形成循环，第一个元素为elements[head]，最后一个是elements[tail-1]，元素索引从head到elements.length-1，然后再从0到tail-1。
	    // 实现原理,以下代码只涉及到核心逻辑，删除了不必要的条件判断。
	    // 成员变量
	    transient Object[] elements;
	    transient int head;
	    transient int tail;
	    // 默认数组大小为16
	    public ArrayDeque() {
	        elements = new Object[16];
	    }
	    // 分配数组大小会严格大于numElements大小且为2的整数次幂的最小数
	    public ArrayDeque(int numElements) {
	        allocateElements(numElements);
	    }
	    private void allocateElements(int numElements) {
	        int initialCapacity = MIN_INITIAL_CAPACITY;
	        // Find the best power of two to hold elements.
	        // Tests "<=" because arrays aren't kept full.
	        if (numElements >= initialCapacity) {
	            // 将最高位的二进制1复制到其余二进制位中，假设numElements，则其二进制位为1010,进行无符号右移1位进行按位或运算之后最后结果为1111
	            initialCapacity = numElements;
	            initialCapacity |= (initialCapacity >>>  1);
	            initialCapacity |= (initialCapacity >>>  2);
	            initialCapacity |= (initialCapacity >>>  4);
	            initialCapacity |= (initialCapacity >>>  8);
	            initialCapacity |= (initialCapacity >>> 16);
	            // 将结果加1取得2次幂的整数，如1111加1得到10000，结果为16
	            initialCapacity++;
	            // 如果结果小于0，说明数组溢出，超过了2^30幂大小，去2^30为最大值
	            if (initialCapacity < 0)    // Too many elements, must back off
	                initialCapacity >>>= 1; // Good luck allocating 2^30 elements
	        }
	        elements = new Object[initialCapacity];
	    }
	    // 为啥分配大小需要2的整数幂?因为可以与numElements - 1进行按位与操作保证head,tail下一个或者上一个数组下标在正确的数组范围内。
	    // 如数组大小16（10000），head为0（0），则head上一个下标是(head - 1) & numElements - 1,即：-1（11111111 11111111 11111111 11111111） & 15（00000000 00000000 00000000 00011111） = 15（11111）
	    // 为啥分配大小需要严格大于numElements，因为tail需要指向下一个空位，所有数组大小需要大于numElements
	    // 头部添加
	    public void addFirst(E e) {
	        // 取得head上一个数组下标复制
	        elements[head = (head - 1) & (elements.length - 1)] = e;
	        // 如果head和tail相同说明，数组已满，进行数组扩容。
	        if (head == tail)
	            doubleCapacity();
	    }
	    // 数组长度变成原来两倍
	    private void doubleCapacity() {
	        assert head == tail;
	        int p = head;
	        int n = elements.length;
	        // head到数组末位的长度
	        int r = n - p; // number of elements to the right of p
	        // 数组长度变成两倍
	        int newCapacity = n << 1;
	        if (newCapacity < 0)
	            throw new IllegalStateException("Sorry, deque too big");
	        Object[] a = new Object[newCapacity];
	        // 将head到数组末位的数据拷贝到新数组头部
	        System.arraycopy(elements, p, a, 0, r);
	        // 将数组头部到head的数据拷贝到新数组head到数组末位数据之后
	        System.arraycopy(elements, 0, a, r, p);
	        // 更新成员变量
	        elements = a;
	        head = 0;
	        tail = n;
	    }
	    // 尾部添加
	    public void addLast(E e) {
	        if (e == null)
	            throw new NullPointerException();
	        // 将数据放置到数组tail下标，
	        elements[tail] = e;
	        // tail指向下一个空位，如果head == tail进行扩容
	        if ( (tail = (tail + 1) & (elements.length - 1)) == head)
	            doubleCapacity();
	    }
	    // 头部删除
	    public E pollFirst() {
	        final Object[] elements = this.elements;
	        final int h = head;
	        @SuppressWarnings("unchecked")
	        E result = (E) elements[h];
	        // Element is null if deque empty
	        // 如果数组不为null，则设置elements[h]为null同时更新head为下一个数组下标
	        if (result != null) {
	            elements[h] = null; // Must null out slot
	            head = (h + 1) & (elements.length - 1);
	        }
	        return result;
	    }
	    // 尾部删除
	    public E pollLast() {
	        final Object[] elements = this.elements;
	        // tail指向上一个数组下标，也就是最后一个数组元素下标
	        final int t = (tail - 1) & (elements.length - 1);
	        @SuppressWarnings("unchecked")
	        E result = (E) elements[t];
	        // 如果数组不为null，则设置elements[t]为null同时更新tail为t，使得tail指向新的空位
	        if (result != null) {
	            elements[t] = null;
	            tail = t;
	        }
	        return result;
	    }
	    // 查找是否包含元素
	    public boolean contains(Object o) {
	        if (o != null) {
	            int mask = elements.length - 1;
	            int i = head;
	            // 从head开始循环遍历，直到数组元素为null
	            for (Object x; (x = elements[i]) != null; i = (i + 1) & mask) {
	                if (o.equals(x))
	                    return true;
	            }
	        }
	        return false;
	    }
	    // 获取数组长度
	    public int size() {
	        // 这个计算很巧妙，因为tail - head小于elements.length - 1且elements.length - 1都是二进制全部都是1,进行按位与
	        // 如果tail - head大于等于0则结果为tail - head,否则结果为elements.length - 1 减去(head - tail)大小
	        return (tail - head) & (elements.length - 1);
	    }


13. LinkedHashMap(JDK1.7)

        LinkedHashMap是HashMap的子类，内部使用一个双向链表维护键值对的顺序，每个键值对既位于哈希表中，也位于这个双向链表中。
        LinkedHashMap支持两种顺序，一种是插入顺序，另外一种是访问顺序。
        插入顺序：先添加的在前面，后添加的在后面，修改操作不影响顺序。
        访问顺序：对一个键执行get/put操作后，其对应的键值对会移到链表末尾，所以，最末尾的是最近访问的，最开始的最久没被访问的。
        // 实现原理,以下代码只涉及到核心逻辑，删除了不必要的条件判断。
        // 成员变量
        private transient Entry<K,V> header;
        private final boolean accessOrder;
        // 构造函数
        public LinkedHashMap(int initialCapacity,
                             float loadFactor,
                             boolean accessOrder) {
            super(initialCapacity, loadFactor);
            // 是按照插入有序还是访问有序
            this.accessOrder = accessOrder;
        }
        // 重写父类init函数，构造空的header节点
        @Override
        void init() {
            header = new Entry<>(-1, null, null, null);
            header.before = header.after = header;
        }
        // 扩展HashMap.Entry使用双链表来维持顺序
        private static class Entry<K,V> extends HashMap.Entry<K,V> {
            // 节点的前驱和后继节点
            Entry<K,V> before, after;

            Entry(int hash, K key, V value, HashMap.Entry<K,V> next) {
                super(hash, key, value, next);
            }
            // 删除节点
            private void remove() {
                before.after = after;
                after.before = before;
            }
            // 将节点添加到existingEntry前面
            private void addBefore(Entry<K,V> existingEntry) {
                after  = existingEntry;
                before = existingEntry.before;
                before.after = this;
                after.before = this;
            }
            // 复写父类方法，如果是访问顺序，调用put/get方法会将删除节点并将节点添加到链表头
            void recordAccess(HashMap<K,V> m) {
                LinkedHashMap<K,V> lm = (LinkedHashMap<K,V>)m;
                if (lm.accessOrder) {
                    lm.modCount++;
                    remove();
                    addBefore(lm.header);
                }
            }
            // 复写父类方法，当Map删除节点时删除双链表中节点
            void recordRemoval(HashMap<K,V> m) {
                remove();
            }
        }
        // 添加元素，调用父类HashMap的put方法，最终会调用addEntry方法
        void addEntry(int hash, K key, V value, int bucketIndex) {
            super.addEntry(hash, key, value, bucketIndex);

            // 第一个节点
            Entry<K,V> eldest = header.after;
            // 如果removeEldestEntry返回true，则会删除第一个节点，如果是访问顺序的话，也就是最久未访问的节点。
            if (removeEldestEntry(eldest)) {
                removeEntryForKey(eldest.key);
            }
        }
        // 父类的addEntry会调用createEntry方法，LinkedHashMap复写createEntry方法
        void createEntry(int hash, K key, V value, int bucketIndex) {
            // 将节点添加到hash表中
            HashMap.Entry<K,V> old = table[bucketIndex];
            Entry<K,V> e = new Entry<>(hash, key, value, old);
            table[bucketIndex] = e;
            // 将节点添加到双链表头部
            e.addBefore(header);
            size++;
        }
        // 获取元素
        public V get(Object key) {
            // 使用getEntry获取hash表中的元素，并把元素移到双链表末尾
            Entry<K,V> e = (Entry<K,V>)getEntry(key);
            if (e == null)
                return null;
            e.recordAccess(this);
            return e.value;
        }
        // 删除元素，调用父类的remove方法
        public V remove(Object key) {
            Entry<K,V> e = removeEntryForKey(key);
            return (e == null ? null : e.value);
        }
        // removeEntryForKey方法会调用recordRemoval方法来删除双链表的节点
        final Entry<K,V> removeEntryForKey(Object key) {
            int hash = (key == null) ? 0 : hash(key);
            int i = indexFor(hash, table.length);
            Entry<K,V> prev = table[i];
            Entry<K,V> e = prev;

            while (e != null) {
                Entry<K,V> next = e.next;
                Object k;
                if (e.hash == hash &&
                    ((k = e.key) == key || (key != null && key.equals(k)))) {
                    modCount++;
                    size--;
                    if (prev == e)
                        table[i] = next;
                    else
                        prev.next = next;
                    // LinkedHashMap复写，删除双链表节点
                    e.recordRemoval(this);
                    return e;
                }
                prev = e;
                e = next;
            }

            return e;
        }
        // 查找值，遍历双链表
        public boolean containsValue(Object value) {
            if (value==null) {
                // 从双链表的第一个节点开始直到header
                for (Entry e = header.after; e != header; e = e.after)
                    if (e.value==null)
                        return true;
            } else {
                for (Entry e = header.after; e != header; e = e.after)
                    if (value.equals(e.value))
                        return true;
            }
            return false;
        }

14. EnumMap

        枚举Map，来存储枚举Key，通过两个数组一个是键数组,一个是值数组，通过键的枚举ordinal作为值数组的下标来存储和获取值，不展开分析。

15. EnumSet

         EnumSet没有使用EnumMap的实例来实现，而是采用二进位的位向量操作来高效实现，使用二进制的位的值1来表示Enum的ordinal。
         EnumSet的实现由Enum的ordinal是否超过64位来决定使用其内部子类RegularEnumSet和JumboEnumSet，RegularEnumSet是使用long整型来表示不超过64位的enum
         JumboEnumSe使用long数组来表示超过64位的enum。
         // 实现原理
         // 成员变量
         // 枚举元素类型
         final Class<E> elementType;
         // 枚举值
         final Enum<?>[] universe;
         // EnumSet是抽象类，不能直接使用new创建，而是使用一系列静态工厂方法创建
         public static <E extends Enum<E>> EnumSet<E> noneOf(Class<E> elementType) {
             Enum<?>[] universe = getUniverse(elementType);
             if (universe == null)
                 throw new ClassCastException(elementType + " not an enum");
             // 枚举值小于等于64
             if (universe.length <= 64)
                 return new RegularEnumSet<>(elementType, universe);
             else
                 return new JumboEnumSet<>(elementType, universe);
         }
         // 针对Set接口的操作，都是通过EnumSet的内部子类来实现，JumboEnumSet的实现都是先通过枚举值>>>6(除以64)来找到long数组的所在索引的long来操作。所以在此只分析RegularEnumSet
         // 添加
        public boolean add(E e) {
            // 类型检查
            typeCheck(e);

            long oldElements = elements;
            // 将枚举e的ordinal值的所对应二进制位置为1
            elements |= (1L << ((Enum<?>)e).ordinal());
            return elements != oldElements;
        }
        // 删除
        public boolean remove(Object e) {
            if (e == null)
                return false;
            Class<?> eClass = e.getClass();
            if (eClass != elementType && eClass.getSuperclass() != elementType)
                return false;

            long oldElements = elements;
            // 将枚举e的ordinal值的所对应二进制位置为0
            elements &= ~(1L << ((Enum<?>)e).ordinal());
            return elements != oldElements;
        }
        // 包含
        public boolean contains(Object e) {
            if (e == null)
                return false;
            Class<?> eClass = e.getClass();
            if (eClass != elementType && eClass.getSuperclass() != elementType)
                return false;
            // 将判读枚举e的ordinal值的所对应二进制位置是否为0
            return (elements & (1L << ((Enum<?>)e).ordinal())) != 0;
        }
        // 大小
        public int size() {
            // 查看elements的二进制位总数是几位
            return Long.bitCount(elements);
        }
        // 删除集合枚举c
        public boolean removeAll(Collection<?> c) {
            if (!(c instanceof RegularEnumSet))
                return super.removeAll(c);

            RegularEnumSet<?> es = (RegularEnumSet<?>)c;
            if (es.elementType != elementType)
                return false;

            long oldElements = elements;
            // 先对集合c的枚举值进行按位取反，原先的二进制中的1变成0,0变成1。然后对其进行取反后的值进行按位与来删除要删除集合的枚举值的二进制中的1的位。
            elements &= ~es.elements;
            return elements != oldElements;
        }
        // 只保留集合c存在的枚举
        public boolean retainAll(Collection<?> c) {
            if (!(c instanceof RegularEnumSet))
                return super.retainAll(c);

            RegularEnumSet<?> es = (RegularEnumSet<?>)c;
            if (es.elementType != elementType) {
                boolean changed = (elements != 0);
                elements = 0;
                return changed;
            }

            long oldElements = elements;
            // 两个枚举值进行按位与来重置二进制
            elements &= es.elements;
            return elements != oldElements;
        }

14. 内存相关概念

        https://blog.csdn.net/javazejian/article/details/72772461
        https://blog.csdn.net/javazejian/article/details/72772461#java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E6%A6%82%E8%BF%B0
        https://zhuanlan.zhihu.com/p/29881777
        https://zh.wikipedia.org/wiki/MESI%E5%8D%8F%E8%AE%AE
        https://blog.csdn.net/reliveIT/article/details/50450136
        https://medium.com/fcamels-notes/%E5%BE%9E%E7%A1%AC%E9%AB%94%E8%A7%80%E9%BB%9E%E4%BA%86%E8%A7%A3-memry-barrier-%E7%9A%84%E5%AF%A6%E4%BD%9C%E5%92%8C%E6%95%88%E6%9E%9C-416ff0a64fc1
        https://zhuanlan.zhihu.com/p/25474331
        Java内存区域划分
        	Class(Method)Area: 存储着类结构,如：运行期常量、字段、方法数据和方法代码。
        	Heap: 运行时数据区，对象内存分配区。
        	Stack: 存储帧，包含局部变量和部分返回结果，在方法调用和返回时起作用。每个线程都拥有一个JVM栈，在线程创建时创建，方法调用时一个新帧创建，方法调用完成时帧被销毁。
        	PC(program counter) register:程序计数器包含当前正在执行JVM指令的地址。
        	Native method Stack: 包含所有的本地方法。
        JMM(Java Memory Model)内存模型
            是一种虚拟机规范，屏蔽各种硬件和操作系统的内存访问差异，实现Java程序在各种平台都能达到一致性的并发效果。
            JMM规范了Java虚拟机与计算机内存如何协调工作，规定了一个线程如何和何时可以看到其他线程修改过后的共享变量的值，以及在必须时如何同步的访问共享变量。
                1. JMM把Java虚拟机内部划分为线程栈(Thread stack)和堆。
                2. 每个线程创建时Java虚拟机会为其创建一个线程栈(Thread stack)用于存储私有的数据，这个线程栈包含了这个线程调用的方法当前执行点相关的信息，一个线程仅能访问自己的线程栈。一个线程中创建的本地变量堆其他线程不可见，仅自己可见。
                3. 一个本地变量可能是原始类型，在这种情况下，它总是“呆在”线程栈上。
                4. 一个本地变量也可能是指向一个对象的一个引用。在这种情况下，引用（这个本地变量）存放在线程栈上，但是对象本身存放在堆上。
                5. 堆上存放着Java程序中创建的所有对象，一个对象的成员变量会随着对象放置在堆中，不管对象的成员变量是原始类型还是引用类型。
                6. 静态成员变量跟随着类定义一起也存放在堆上。
                7. 堆上的对象可以被所有持有对这个对象引用的线程访问。当一个线程可以访问一个对象值时，通过对象引用找到堆上对象的值，加载堆上的值到线程本地内存中(load)，建立一个本地变量副本，
                后续的操作都是针对本地变量副本，在更新本地变量后的某个时刻(线程退出前)会把本地变量的值写回到堆中(store).
        硬件内存架构
            计算机硬件内存架构涉及到CPU,寄存器，高速缓存cache,内存。
            通常情况下，当一个CPU需要读取主存时，它会将主存的部分读到CPU缓存中。它甚至可能将缓存中的部分内容读到它的内部寄存器中，
            然后在寄存器中执行操作。当CPU需要将结果写回到主存中去时，它会将内部寄存器的值刷新到缓存中，然后在某个时间点将值刷新回主存。
        Java内存区域和JMM内存模型是不同的概念层次。
        Java内存模型与硬件内存架构之间存在差异。硬件内存架构没有区分线程栈和堆。对于硬件来说，所有的线程栈和堆可能会出现在CPU缓存，CPU内部的寄存器，主内存中。
        当对象和变量被存放在计算机中各种不同的内存区域中时，可能会出现一些具体的问题
            1. 共享变量的可见性（共享变量分布在主内存中，多个线程的线程栈存放在缓存或者寄存器中，其中一个线程加载共享变量到缓存中并修改，修改后的共享变量对其他线程是不可见的）。
            2. 读写检查共享变量可能会出现竟态条件(共享变量分布在主内存中，多个线程的线程栈存放在缓存或者寄存器中, 多个线程在这个共享对象上更新变量并写回主内存，其结果是不可知的)。
        指令重排
            计算器在执行程序的过程中，为了提高性能，编译器或者处理器常常会对指令进行重新排序。
            编译器优化的重排
                编译器不改变单线程程序语义下，可以重新安排语句的执行顺序。
            指令并行的重排
                现代处理器采用了指令级并行技术来将多条指令重叠执行，如果不存在数据依赖性(即后一个执行的语句无需依赖前面执行的语句的结束)，处理器可以改变语句对应的机器指令执行顺序。
            内存系统的重排
                由于处理器使用缓存和读写缓存冲取，这使得加载(load)和存储(store)操作看上去可能是乱序执行，因为三级缓存的存在，导致了内存和数据的同步存在时间差。
        原子性
            指一个操作是按原子的方式执行的。要么该操作不被执行；要么以原子方式执行，即执行过程中不会被其它线程中断。
        可见性
            线程对共享变量修改的可见性。当一个线程修改了共享变量的值，其他线程能够立刻得知这个修改
        as-if-serial语义
            不管怎么重排序(编译器和处理器为了提高并行度)，(单线程)程序的执行结果不能被改变。(编译器，runtime和处理器都必须遵守as-if-serial语义)。
        happens before
            1. 如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。
            2. 两个操作之间存在happens-before关系，并不意味着一定要按照happens-before原则制定的顺序来执行。如果重排序之后的执行结果与按照happens-before关系来执行的结果一致，那么这种重排序并不非法。
            happens-before原则规则：
                程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作；
                锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作；
                volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作；
                传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C；
                线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作；
                线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生；
                线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行；
                对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始；
        内存屏障(Memory Barriers)
            重排序可能会导致多线程程序出现内存可见性问题。对于处理器重排序，JMM的处理器重排序规则会要求Java编译器在生成指令序列时，
            插入特定类型的内存屏障(Memory barriers, Intel称之为Memory Fence)指令，通过内存屏障指令来禁止特定类型的处理器重排序。通过
            禁止特性类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。
        缓存一致性
            保留在缓冲存储器中的共享资源，保持数据一致性的机制。
        MESI(https://blog.csdn.net/zhuliting/article/details/6210921)
            MESI协议是一个基于失效的缓存一致性协议，是支持回写（write-back）缓存的最常用协议。
            状态
                MESI协议将cache line的状态分成modify、exclusive、shared、invalid，分别是修改、独占、共享和失效。
                    Modify：当前CPU cache拥有最新数据（最新的cache line），其他CPU拥有失效数据（cache line的状态是invalid），虽然当前CPU中的数据和主存是不一致的，但是以当前CPU的数据为准；
                    Exclusive：只有当前CPU中有数据，其他CPU中没有改数据，当前CPU的数据和主存中的数据是一致的；
                    Shared：当前CPU和其他CPU中都有共同数据，并且和主存中的数据一致；
                    Invalid：当前CPU中的数据失效，数据应该从主存中获取，其他CPU中可能有数据也可能无数据，当前CPU中的数据和主存被认为是不一致的；
                    对于invalid而言，在MESI协议中采取的是写失效（write invalidate）。
            操作
                MESI协议中，每个cache的控制器不仅知道自己的操作（local read和local write），每个核心的缓存控制器通过监听也知道其他CPU中cache的操作（remote read和remote write），进而再确定自己cache中共享数据的状态是否需要调整。
                    local read（LR）：读本地cache中的数据；
                    local write（LW）：将数据写到本地cache；
                    remote read（RR）：其他核心发生read；
                    remote write（RW）：其他核心发生write；

15. 线程

        https://www.zhihu.com/question/25532384
        https://www.jianshu.com/p/32e1361817f00
        https://segmentfault.com/a/1190000016416989
        http://mrpeak.cn/operating%20system/2016/01/16/threading-lock
        http://beanlam.me/syncprimitive/
        进程：应用程序的执行实例。
        线程：一个程序里面不同的执行路径。线程共享进程的上下文，因此相对进程开销更新。
        线程实现
            1. 实现Runnable接口
            2. 继承Thread类
        线程状态
            1. NEW: NEW创建了一个Thread对象，但还未调用start()启动线程。
            2. RUNNABLE: 已经在JAVA虚拟机中运行，但可能还在等待处理器进行调度(READY)。
            3. BLOCKED: 阻塞等待获取Monitor lock。
            4. WAITING: 当执行Object.wait, Thread.join,LockSupport.park函数时，线程进入WAITING,
            当前线程会释放Monitor所有权和等待其他线程执行相应的动作(Object.notify/notifyAll,线程终止，LockSupport.unpark)。
            5. TIME_WAITING: 当执行Thread.sleep,Object.wait(time),Thread.join(time), LockSupport.parkNanos, LockSupport.parkUntil函数时,线程进入TIME_WAITING。
            不需要等待其他线程的动作，在一定时间之后由系统进行唤醒。
            6. TERMINATED: 线程执行完成。
        线程相关关键方法
            1. Thread.sleep线程暂停执行，进入TIME_WAITING状态，不会丢失Monitor所有权。
            2. Thread.join等待调用线程终止，内部调用Object.wait来实现。
            3. Thread.yield让出处理器调度，线程状态由运行态进入可运行态，让OS再次选择调度线程。
            4. Thread.interrupt中断线程，这里所谓的中断线程，并不是直接停止线程，而是设置线程的中断标志位或者抛出一些异常。具体操作取决于要中断线程的状态:
               4-1. 当前线程因为调用Object.wait/wait(time), Thread.join/join(time), Thread.sleep/sleep(time)而处于WAITING或者TIME_WAITING,调用interrupt会导致线程抛出InterruptedException并清除中断标志位。
               4-2. 当前线程因为InterruptibleChannel阻塞等待I/O操作，调用线程的interrupt会导致InterruptibleChannel通道被关闭和抛出ClosedByInterruptException并设置线程中断标志位。
               4-3. 当前线程因为Selector阻塞等待操作，调用线程的interrupt会设置线程的中断标志位并直接返回。
               4-4. 当前线程不是isAlive状态(线程已经started但没有死亡),调用线程的interrupt没有任何效果。
               4-5. 其他情况，线程会设置线程中断标志位，线程可以判断线程的中断标志位来决定是否终止线程。
            5. Thread.interrupted/isInterrupted测试线程是否被中断(线程标志位是否被设置)，interrupted会清除中断标志位，isInterrupted不会清除中断标志位。
            6. Object.wait阻塞等待直到其他线程调用Object.notify/notifyAll,调用此方法的线程必须拥有Monitor所有权也就是说必须在同步语句(Synchronized)中, 调用此方法会释放线程拥有的Monitor同时让线程进入Monitor的Wait set
            中阻塞等待其他线程的动作(Object.notify/notifyAll)。
            7. Object.notify/notifyAll唤醒阻塞等待Monitor对象wait set中的一个线程(notify)或者所有线程(notifyAll),唤醒的线程会同其他申请Monitor所有权的线程进行竞争Monitor所有权，唤醒的线程和其他申请Monitor所有权的线程
            会阻塞等待notify/notifyAll线程释放Monitor所有权，只有获取Monitor所有权的线程才能从wait方法中返回并继续运行，其他同其竞争的没有获取到Monitor所有权的线程会恢复到以前状态也就是重新回到Monitor对象的Wait set中进行阻塞等待。
            8. 虚假唤醒：即使线程没有broadcast 或者signal条件变量，wait也可能偶尔返回（https://en.m.wikipedia.org/wiki/Spurious_wakeup）。
            9. 条件变量：一个线程在某个条件为真时，才能继续运行，否则一直阻塞等待（https://zh.wikipedia.org/wiki/%E7%9B%A3%E8%A6%96%E5%99%A8_(%E7%A8%8B%E5%BA%8F%E5%90%8C%E6%AD%A5%E5%8C%96)#%E6%A2%9D%E4%BB%B6%E8%AE%8A%E6%95%B8(Condition_Variable)）。
            10. Object.wait/Object.notify/notifyAll经典示例：
                synchronized(obj) {
                    while(条件变量){
                        obj.wait();
                    }
                    // 其他语句
                }
                synchronized(obj) {
                    // 修改条件变量为真
                    obj.notify()/notifyAll();
                }

16. 并发编程相关概念

        https://www.zhihu.com/question/33515481
        https://zh.wikipedia.org/wiki/%E6%AD%BB%E9%94%81
        https://www.jianshu.com/p/44125bb12ebf
        https://zhuanlan.zhihu.com/p/26945588
        https://zhuanlan.zhihu.com/p/86659685
        https://wiki.jikexueyuan.com/project/java-concurrent/thread-safety-and-immutability.html
        并发：系统中有多个任务同时存在
        并行：系统中有多个任务同时运行
        死锁：当两个以上运算单元，双方都在等待对方停止运行，以获取系统资源，但是没有一方提前退出时，称为死锁。
        (线程中死锁的个人理解：两个或者两个以上线程持有独占资源(如：Monitor,独占锁)并且互相等待其他线程的独占资源会导致线程一直阻塞等待，这种现象成为死锁)
        死锁的四个条件
            1. 互斥条件：一个资源每次只能被一个线程使用。
            2. 请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。
            3. 不可剥夺条件：线程已获得的资源，在未使用完之前，不能强行剥夺。
            4. 循环等待条件：若干线程之间形成一种头尾相接的循环等待资源关系。
        死锁的预防与检测：
            1. 预防死锁，围绕死锁的四个条件来，只要破坏其中的死锁的条件就可以避免死锁（如：设置获取锁的顺序，定时锁）。
            2. 死锁检测（JStack, JConsole）。
            3. 死锁恢复（重启）。
        活锁：行程彼此释放资源又同时占用对方释放的资源，当此情况持续发生时，尽管资源的状态不断改变，但每个行程都无法获取所需资源，使得事情没有任何进展。
        竞态条件：当两个线程竞争同一资源时，如果对资源的访问顺序敏感，就称存在竞态条件。
        临界区：导致竞态条件发生的代码区称作临界区。
        幂等性：一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。
        线程安全代码：允许被多个线程同时执行的代码称作线程安全代码，线程安全代码不包含竞态条件。
        共享资源：允许被多个线程所读写的资源，如堆中所分配的对象。当多个线程同时更新共享资源就有可能引发竞态条件。
        可重入：若一个程序或子程序可以“在任意时刻被中断然后操作系统调度执行另外一段代码，这段代码又调用了该子程序不会出错”，则称其为可重入（reentrant或re-entrant）的。即当该子程序正在运行时，执行线程可以再次进入并执行它，仍然获得符合设计时预期的结果。与多线程并发执行的线程安全不同，可重入强调对单个线程执行时重新进入同一个子程序仍然是安全的。
        避免竞态条件：在临界区使用适当的同步(synchronized, Lock)。
        线程开销：启动一个线程需要消耗一些系统资源，同时需要分配一些内存来存储线程的本地栈。
        上下文切换：cpu会给每个线程分配一段时间片，当一个cpu从一个线程切换成另一个线程时，cpu需要保存当前线程的本地数据，程序指针等，然后再载入另一个线程的本地数据，程序指针，最后才开始执行。这种保存和加载称为上下文切换。
        减少上下文切换：无锁并发编程、CAS、使用最少线程、协程。
        减少上下文切换的方法有：无锁并发编程、CAS、使用最少线程、协程。
            1. 无锁并非：通过某种策略（比如hash分隔任务）使得每个线程不共享资源。避免锁的使用。
            2. CAS：是比锁更轻量级的线程同步方式。
            3. 避免创建不需要的线程，避免线程一直处于等待状态。
            4. 协程： 单线程实现多任务调度，单线程维持多任务切换。

17. 线程同步

        https://blog.csdn.net/guoxiang3538/article/details/79376191
        https://crossoverjie.top/2018/03/16/java-senior/thread-communication/
        https://baike.baidu.com/item/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5
        为了线程安全的更新共享资源或者为了协调线程间执行顺序，线程之间需要借助一些同步机制或者同步工具来保证。
        1. 等待通知机制(wait/notify/notifyAll)
        2. Lock/Condition
        3. Semaphore
        4. join
        5. 共享内存
        6. CountDownLatch
        7. CycleBarrier
        8. Interrupted
        9. awaitTermination
        10. 管道(PipedWriter/PipedReader)
        11. 并发集合
        12. volatile
        13. synchronized
        14. Atomic

18. volatile原理

        https://www.cnblogs.com/dolphin0520/p/3920373.html
        https://www.infoq.cn/article/java-memory-model-4/
        https://juejin.im/post/5ae9b41b518825670b33e6c4#heading-5
        volatile修饰的共享变量能够保证每个线程每次获取该共享变量的值都是内存中最新的值。
        被volatile修饰的共享变量具有两层语义：
            1. 内存的可见性。
            2. 禁止指令重排。
        volatile汇编上的实现
            被volatile修饰的共享变量在转化成汇编代码会使用Lock前缀指令修饰，该指令在多核处理器中会触发以下事情：
                1. Lock前缀的指令会引起处理器缓存写回内存。
                2. 一个处理器的缓存回写到内存会导致其他处理器的缓存失效。
                3. 当处理器发现本地缓存失效会从内存中重新读取该变量的值（每个处理器通过嗅探总线上传播的数据来检查自己的缓存的值是不是过期(MESI)）。

        volatile内存语义：
            1. 当写一个volatile变量时，JMM会把该线程对应的本地内存中共享变量刷新到主内存（写内存语义）。
            2. 当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效，线程接下来会从主内存中读取共享变量（读内存语义）。
            volatile 仅仅保证对单个 volatile 变量的读写操作具有原子性，而锁的 互斥则可以确保整个临界区代码执行的原子性。
        volatile内存语义实现
            JMM在不改变正确语义的前提下，会允许处理器指令重排序。为了正确实现volatile内存语义，volatile会在编译器生成字节码时，会在指令序列中
            插入内存屏障禁止特定类型的处理器重排序。对于编译器来说，发现一个最优布置来最小化插入内存屏障的总数几乎不可能，为此JMM采取保守策略。下面是基于保守策略的JMM内存屏障插入策略：
                1. 在每个volatile写操作前面插入一个StoreStore屏障。
                2. 在每个volatile写操作后面插入一个StoreLoad屏障。
                3. 在每个volatile读操作后面插入一个LoadLoad屏障。
                4. 在每个volatile读操作后面插入一个LoadStore屏障。
            StoreStore屏障：禁止上面的普通写和下面的volatile写重排序。
            StoreLoad屏障：防止上面的volatile写与下面可能有的volatile读/写重排序
            LoadLoad屏障：禁止下面的所有普通读操作和上面的volatile读重排序。
            LoadStore屏障：禁止下面所有的普通写操作和上面的volatile读重排序。

19. synchronized原理

        https://blog.csdn.net/javazejian/article/details/72828483
        https://www.jianshu.com/p/d53bf830fa09
        https://crossoverjie.top/2018/01/14/Synchronize/
        https://zhuanlan.zhihu.com/p/29866981
        https://zhuanlan.zhihu.com/p/109482603
        https://juejin.im/post/5d96db806fb9a04e0f30f0eb
        https://blog.csdn.net/tongdanping/article/details/79647337
        https://www.jianshu.com/p/32e1361817f0
        synchronized作用
            1. synchronized可以保证在同一时刻，只有一个线程可以执行某个方法或者某个代码块(主要是对方法或者代码块中存在共享数据的操作)。
            2. synchronized可保证一个线程的变化（主要是共享数据的变化）被其他线程锁看到。
        synchronized三种应用方式
            1. 修饰实例方法，对当前实例加锁，进入同步代码前要获得当前实例的锁。
            2. 修饰静态方法，对当前类对象加锁，进入同步代码块前要获得当前类对象的锁。
            3. 修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码块前要获得给定对象的锁。
        synchronized实现原理
            锁内存语义
                synchronized的底层是使用操作系统的互斥锁(mutex lock)实现的：
                    内存可见性：同步块的可见性是有“如果一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化此变量的值”、
                    “对一个变量执行unlock操作之前，必须先把此变量同步回主内存（执行store和write操作”这两条规则获得的。
                    操作原子性：持有同一个锁的两个同步块只能串行地进入。
                互斥锁：同于保护临界区，确保同一时间只有一个线程访问数据。对共享资源的访问，先对互斥量进行加锁，如果互斥量已经上锁，调用线程会阻塞，直到互斥量被解锁。在完成了对共享资源的访问后，要对互斥量进行解锁。
                因此使用synchronize对共享变量访问保证了
                    当线程释放锁时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中。
                    当线程获取锁时，JMM会把该线程对应的本地内存置为无效。从而使得被监听器保护的临界区代码必须从主内存中读取共享变量。
            monitor（对象监听器）
                synchronized在JVM中是基于monitorenter和monitorexit两个指令实现的，monitorenter指令在编译后插入到同步代码块的开始位置，monitorexit插入到该同步块的结束位置或者异常处。
                任何一个对象都有一个monitor与之关联，当一个monitor被某个线程持有之后，该对象将处于锁定状态。线程执行到monitorenter指令时，会尝试获取该对象对应的monitor所有权，也即获得对象的锁。
                monitorenter和monitorexit操作对应的锁对象是隐式的。对于实例方法来说,这两个操作对应的锁是this;对于静态方法来说，这两个操作对应的锁对象则是所在类的Class实例。
            ObjectMonitor（Hotspot）（重量级锁）
                monitor在Hotspot中是通过ObjectMonitor对象(C++)实现,其同步数据结构如下:
                ObjectMonitor() {
                    _count        = 0; // 用来记录该对象被线程获取锁的次数
                    _recursions   = 0; //锁的重入次数
                    _owner        = NULL; //持有ObjectMonitor对象的线程
                    _WaitSet      = NULL; //处于WAITING状态的线程会被加入到_WaitSet(线程调用wait)
                    _EntryList    = NULL ; //竞争ObjectMonitor所有权失败线程进入BLOCKED状态，会被加入到该列表
                  }
                对于一个synchronized修饰的方法(代码块)来说：
                    1. 当多个线程同时访问该方法，那么这些线程会先被放进_EntryList队列，此时线程处于BLOCKED状态。
                    2. 当一个线程获取到了监听器锁(monitor)，则从_EntryList队列中移出并赋值与_owner，线程进入RUNNING状态，此时ObjectMonitor对象的_owner指向当前线程，_count加一表示当前对象锁被一个线程获取。
                    3. 当线程获取监听器锁(monitor)的线程调用wait()方法,那么当前线程释放monitor对象同时进入_WaitSet队列，线程进入WAITING状态，此时ObjectMonitor对象的_owner变为null,_count减一，等待其他线程调用notify/notifyAll。
                    4. 当其他线程调用了notify/notifyAll，释放监听器锁(monitor)并唤醒_WaitSet中的某个线程或者所有线程，这时线程会进入到_EntryList队列中竞争监听器锁(monitor)，此时线程处于BLOCKED状态。成功获取监听器锁(monitor)的线程同第二条流程一样。
                    5. 当遇到synchronized关键字的作用范围结束时，ObjectMonitor对象的_owner变为null，_count减1，退出。

            Java对象与ObjectMonitor关联关系
                对象内存堆分布
                    对象头：由MarkWord和KClass Point（类型指针）组成，其中KClass Point是对象指向它的类元数据的指针，虚拟机通过这个指针来确定对象是哪个类的实例，MarkWord用于存储对象自身的运行时数据。
                    如果对象是数组对象，那么对象头占用3个字宽(Word),如果对象是非数组对象，那么对象头占用2个字宽(1word=2 bytes = 16bit)。
                    实例变量：存储的是对象的属性信息，包括父类的属性信息，按照4字节对齐。
                    填充字符：因为虚拟机要求对象字节必须是8字节的整数倍，填充字符就是用于凑齐这个整数倍的。
                对象头中Mark Word存储着指向ObjectMonitor的指针

            锁优化
                Java6之前，synchronized使用的是重量级锁来实现的，重要级锁本质是依赖于底层操作系统的Mutex Lock(互斥锁)来实现的，每个对象都对应一个可称作为“互斥锁”的标记，这个标记用于保证在同一时刻，只能由一个线程访问该对象。
                因为Mutex Lock需要从用户态切换到内核态，状态切换需要耗费很多处理器的时间。因此synchronized在Java6之前是一个重量级的操作。Java6中，虚拟机中对synchronized进行了一些优化，如通知操作系统阻塞线程之前加入一段自旋等待过程，避免频繁地切入到核心态中。
                Java SE 1.6为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”，因此锁一共有四种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态。锁可以升级但不能降级。
                在运行期间，Mark Word存储的数据会随着锁标志位变化而变化，以32位的JDK为例：
                无锁： 对象的hashCode,分代年龄，偏向锁标志(0)，锁标志(01)
                偏向锁：线程ID，Epoch,分代年龄，偏向锁标志(1), 锁标志(01)
                轻量级锁：指向锁记录的指针，                   锁标志(00)
                重量级锁：指向重量级锁的指针，                 锁标志(10)
                GC标志：空                                     锁标志(11)

                CAS:
                    重量级锁是一种悲观锁策略（假设会出现冲突），假设每次执行临界区代码都会产生冲突，所以当前线程获取到锁的同时会阻塞其他线程获取该锁。
                    CAS(compare and swap)是一种乐观锁策略(假设不会发生冲突)，它假设所有线程访问共享资源不会出现冲突，因此不会阻塞其他线程。通过比较交换来鉴别线程是否出现冲突，
                    出现冲突就重试当前操作直到没有冲突为止。
                    CAS比较交换的过程可以通俗的理解为CAS(V,O,N)，包含三个值分别为：V 内存地址存放的实际值；O 预期的值（旧值）；N 更新的新值。
                    当V和O相同时，也就是说旧值和内存中实际的值相同表明该值没有被其他线程更改过，即该旧值O就是目前来说最新的值了，自然而然可以将新值N赋值给V。反之，V和O不相同，
                    表明该值已经被其他线程改过了则该旧值O不是最新版本的值了，所以不能将新值N赋给V，返回V即可。当多个线程使用CAS操作一个变量是，只有一个线程会成功，并成功更新，
                    其余会失败。失败的线程会重新尝试，当然也可以选择挂起线程。
                    CAS实现需要硬件指令集支撑，在JDK4.5后虚拟机使用处理器提供的CMPXCHG指令实现。

                偏向锁
                    偏向锁会偏向第一个指向它的线程，如果该锁后续没有其他线程访问过，那我们就不需要加锁直接执行即可。
                    如果后续发现了有其他线程正在获取该锁，那么会根据之前获得锁的线程状态来决定要么锁重新偏向新的线程，要么撤销偏向锁升级为轻量级锁。
                    偏向锁特征：锁不存在多线程竞争，并且应由一个线程多次获得锁。
                    引入偏向锁的原因：HotSpot作者经过研究发现，大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。
                    偏向锁获取(判断是否可偏向状态->测试线程ID->CAS竞争锁->偏向或者撤销升级锁)：
                        1. 访问Mark Word的锁标志是否是(01),偏向锁标志是否是1，确定是否是可偏向状态。
                        2. 如果是可偏向状态，测试Mark Word的线程ID是否指向当前线程，如果是，执行同步块代码，否则进行CAS竞争锁。
                        3. 如果Mark Word线程ID不是指向当前线程，使用CAS竞争锁，竞争成功，将Mark Word线程ID指向当前线程并执行同步块代码，否则进入竞争锁失败流程。
                        4. 如果CAS竞争偏向锁失败则表示有竞争(至少有过其他线程曾经获得过偏向锁，因为线程不会主动释放偏向锁)。当达到全局安全点(safepoint)时，
                        则首先暂停拥有偏向锁的线程，然后检查持有偏向锁线程的状态。如果线程不处于活动状态，则将对象头设置成无锁状态(锁标志01，偏向标志0),然后重新偏向新的线程，
                        如果线程仍然活着，撤销偏向锁升级成轻量级锁(00),此时轻量级锁有原来持有偏向锁的线程持有并执行其同步块代码，而正在竞争的线程进入自旋等待获得轻量级锁。
                    偏向锁撤销(CAS竞争锁->全局安全点暂停偏向锁线程->根据偏向锁线程状态来偏向新的线程还是升级成轻量级锁)：
                        偏向锁使用了一种等到竞争才释放偏向锁的机制：偏向锁只有遇到其他线程尝试竞争偏向锁，持有偏向锁的线程才会释放锁。
                        线程不会主动去释放偏向锁，偏向锁的撤销需要等待全局安全点(在这个时间点上没有字节码正在运行)，它首先会暂停拥有偏向锁的线程，
                        判断锁对象是否处于被锁定状态，撤销偏向锁到未锁定状态(01,0)并偏向新的线程或升级成轻量级锁(00)的状态。
                    关闭偏向锁：
                        偏向锁在Java 6和Java 7默认是启用的。由于偏向锁时为了支援一个线程执行同步块提高性能，如果确定应用程序所有的锁通常情况下处于竞争状态，
                        可以通过JVM参数关闭偏向锁:-XX:-UseBiasedLocking=false,那么程序默认会进入轻量级状态。

                轻量级锁
                    轻量级锁是为了在线程近乎交替执行同步块时提高性能。
                    轻量级锁使用 CAS 和自旋锁来获取锁从而降低使用操作系统互斥量来完成重量级锁的性能消耗。
                    引入轻量级锁的原因：轻量级锁认为存在竞争，但是竞争程度很轻，一般两个线程对于同一个锁的操作会错开或者稍微等待一下(自旋)，另一个线程就会释放锁。
                    当时当自旋超过一定的次数或者一个线程在持有锁，一个在自旋，又有第三个来访，轻量级锁膨胀为重量级锁，重量级锁除了拥有锁的线程以外的线程都阻塞，防止CPU空转。
                    轻量级的获取（建立Lock Record -> 复制Mark Word到Lock Record(Displace Mark Word)-> CAS更新 -> 执行同步块或者CAS自旋尝试-> 膨胀成重量级锁）：
                        1. 在当前线程栈中创建存储锁记录的空间（Lock Record），将对象头的Mark Word复制到线程栈的Lock Record（Displaced Mark Word）, 使用CAS将对象头的Mark Word更新成执行Lock Record
                        的指针，并将Lock Record里的owner指针指向Object Mark Word。
                        2. 如果当前线程CAS更新操作成功, Mark Word锁标志置为00，则当前线程获得锁并执行同步代码块。
                        3. 如果当前线程CAS更新操作失败，检查Mark Word的指针是否指向当前线程的Lock Record，如果是说明当前线程已经获得锁，则可以直接执行同步代码块，否则CAS自旋竞争锁。
                        4. 如果当前线程CAS自旋尝试竞争锁超过一定次数(默认10次)或者有第三个线程尝试CAS更新操作，轻量级锁膨胀成重量级锁，同时线程挂起进入阻塞状态。
                    轻量级锁的释放：
                        1. 通过CAS操作尝试把线程栈中的Lock Record替换回对象头的Mark Word中。
                        2. CAS替换成功, 释放锁同步完成。
                        3. CAS替换失败，说明此时锁已经膨胀成重量级锁(其他线程尝试过获取锁失败将对象头的Mark Word更新成重量级锁的指针)，那这时就要在释放锁的同时唤醒被挂起的线程。

                自旋锁
                    不阻塞线程，不放弃CPU执行时间而是执行死循环不断（有限的次数）的争夺锁，从而避免了挂起和恢复线程的开销，进一步提升响应时间。
                    引入原因：线程的阻塞和唤醒需要CPU从用户态切换为内核态，频繁的阻塞和唤醒对CPU来说是一件负担很重的工作，势必给系统的并发性能带来很大的压力。
                    自旋锁默认的次数为 10 次可以通过 -XX:PreBlockSpin 来更改。

                自适应自旋锁
                    跟自旋锁类似，不同的是它的自旋时间和次数不再固定，而是由上一次在同一个锁上的自旋时间以及锁的拥有者的状态决定。
                    如果线程自旋成功了，那么JVM就会认为下一次也能成功获得锁，其自旋时间和次数也会更多；如果线程对于某个锁，很少有自旋成功获得锁，
                    那么线程在以后获得这个锁的时候其自旋时间和次数也会更少，甚至忽略自旋过程，避免浪费处理器资源。

                锁消除
                    锁消除主要是编译器优化操作，删除不必要的加锁操作。虚拟机即时编译器在运行时，对一些“代码上要求同步，但是被检测到不可能存在共享数据竞争”的锁进行消除。
                    根据代码逃逸技术，如果判断到一段代码中，堆上的数据不会被逃逸出当前线程，那么可以认为这段代码是线程安全的，不必要加锁。
                    public void f() {
                        Object obj = new Object();
                        synchronized(obj) {
                             System.out.println(obj);
                        }
                    }
                    根据代码逃逸技术，f()中的对象只会被一个线程所拥有，那么就会取消同步。
                    public void f() {
                        Object obj = new Object();
                        System.out.println(obj);
                    }

                锁粗化
                    如果在一段代码中连续对同一个对象反复加锁解锁，会导致必要的性能损耗，这种情况下适当放宽加锁的范围(粗化)，减少性能消耗。
                    for (int i = 0; i < 10000; i++) {
                        synchronized(this) {
                            do();
                        }
                    }
                    JIT发现一系列操作都对同一对象反复加锁和解锁，甚至加锁操作出现在循环体中的时候，会将加锁同步的范围扩散到整个操作序列的外部。
                    synchronized(this) {
                        for (int i = 0; i < 10000; i++) {
                            do();
                        }
                    }


20. 原子操作实现原理

        https://juejin.im/post/5d0dac7c5188253298401919
        https://zhuanlan.zhihu.com/p/33445834
        https://www.windsings.com/posts/2a85d31f/
        https://www.infoq.cn/article/atomic-operation
        https://stackoverflow.com/questions/14758088/how-are-atomic-operations-implemented-at-a-hardware-level
        原子(atom)本意是“不能被进一步分割的最小粒子”，而原子操作(atomic operation)意为“不可被中断的一个或一序列操作”。
        原子操作的实现来说，需要分开考虑单处理器单核系统，和多处理器系统，多核系统。
        单核系统(单指令->多指令->spinlock保证操作指令不被干扰):
            只要保证操作指令序列不能被打断即可实现原子操作(对于内存的读写操作，需要地址对齐，否则就不是一次内存读写，也就不是原子操作)。
            简单原子操作，cpu实现上会提供单条指令，比如INC，XCHG等。对于复杂的原子操作，需要包含多条指令。执行过程中，出现上下文切换行文，
            比如任务切换，中断处理等。这里的行为会影响到原子操作的原子性。因此需要自旋锁spinlock来保证操作指令序列不好再执行的中途受干扰。
        多处理器或者多核的系：
            原子操作的实现除了需要spinlock来保证外，还需要保证不好受到同处理器上其他核或者其他处理器的影响。
            当其他核上执行的指令访问内存空间，与当前原子操作需要访问的内存空间存在冲突时，就会破坏原子操作的正确性。
            32位IA-32处理器使用机遇对缓存加锁和总线加锁的方式来实现多处理直接的原子操作。
            总线锁：
                 处理器提供一个LOCK#信号，当一个处理器再总线上输出此信号时，其他处理器的请求将被阻塞住，那么该处理器可以独占使用共享内存。
            缓存锁：
                锁总线的方式，可以有效的防止其他处理器的内存访问，但是其效率是及其低下的。我们只需对保证对某个内存地址的操作是原子性即可实现原子操作。
                因此很多处理器引入缓存锁定来替代总线锁定来实现原子操作：
                “缓存锁定”利用处理器CAS硬件支持，只阻塞处理器对相关内存区域的访问，通过缓存一致性来保证操作的原子性。
        Java原子操作实现
            通过锁和自旋CAS的方式来实现原子操作。
            自旋CAS问题：
                ABA问题：
                    CAS操作依据硬件的CMPXCHG指令来保证原子性，CAS操作是通过比较内存地址的实际值和预期的值是否相同来决定是否更新目标值。这里就可能产生
                    当实际内存的值A修改成B再修改回A(A->B->A),其他线程的CAS操作并无法判读实际内存的值是否有过更改。
                    解决方案：
                        ABA问题的解决思路使用版本号。在变量前面追加版本号，每次变量更新的时候把版本号加一，那么A->B->A就可能变成1A->2B->3A。
                        Java 1.5开始JDK的atomic包里提供一个类AtomicStampedReference来解决ABA问题。这个类的compareAndSet方法首先检查当前引用是否等于预期引用
                        并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。
                循环时间长开销大：
                    自旋 CAS 如果长时间不成功，会给 CPU 带来非常大的执行开销。如果 JVM 能支持处理器提供的 pause 指令那么效率会有一定的提升，pause 指令有两个作用，
                    第一它可以延迟流水线执行指令（de-pipeline）, 使 CPU 不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。
                    第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起 CPU 流水线被清空（CPU pipeline flush），从而提高 CPU 的执行效率。
                只能保证一个共享变量的原子操作：
                    当对一个共享变量执行操作时，我们可以使用循环 CAS 的方式来保证原子操作，但是对多个共享变量操作时，循环 CAS 就无法保证操作的原子性，这个时候就可以用锁，
                    或者有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。Java1.5 开始 JDK 提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作。
            锁
                锁机制保证了只有获得锁的线程才能给操作锁定的区域。 JVM 的 内部实现了多种锁机制。除了偏向锁，其他锁的方式都使用了循环 CAS，也就是当一个线程 想进入同步块的时候，
                使用循环 CAS 方式来获取锁，退出时使用 CAS 来释放锁。



21. 操作系统同步原语


        https://blog.csdn.net/H002399/article/details/46581481
        http://beanlam.me/syncprimitive/
        https://juejin.im/post/5c3351266fb9a049a5711190
        https://cloud.tencent.com/developer/article/1558007
        https://zhuanlan.zhihu.com/p/56159336
        https://zhuanlan.zhihu.com/p/89389678
        https://www.jianshu.com/p/3b7d1a354291
        https://zhuanlan.zhihu.com/p/88193886
        https://blog.csdn.net/daiyibo123/article/details/46311933
        https://github.com/hippowc/hippowc.github.io/wiki/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7--%E9%94%81%EF%BC%8C%E4%BF%A1%E5%8F%B7%E9%87%8F%EF%BC%8C%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F
        原语：内核或者微核提供核外调用的过程或者函数称为原语(primitive), 是一段用机器指令编写的完成特定功能的程序，在执行过程中不被允许中断。
        在多道程序环境下，进程是并发执行的，不同进程之间存在着不同的相互制约关系，为了协调进程之间的相互制约关系，引入了进程同步的概念。
        操作系统中同步相关的原语有：条件变量，互斥锁，信号量，互斥量等
        同步相关的关键词有：临界资源，同步，互斥，条件变量，互斥锁，信号量、互斥量，屏蔽中断，TSL指令。
        临界资源：
            虽然多个进程可以共享系统中的各种资源，单其中许多资源一次只能为一个进程所使用，我们把一次仅允许一个进程使用的资源称为临界资源。
            许多物理设备都属于临界资源，如打印机等。此外，还有许多变量、数据等偶读可以被若干进程共享，也属于临界资源。
        对临界资源的访问，必须互斥地进行，在每个进程中，访问临界资源的那段代码称为临界区。为了保证临界资源的正确使用，可把临界资源的访问过程分成四个部分：
            进入区：为了进入临界区使用临界资源，在进入区要检查可否进入临界区，如果可以进入临界区，则应设置正在访问临界区的标志，以阻止其他进程同时进入临界区。
            临界区：进程中访问临界资源的那段代码，又称临界段。
            退出区：将正在访问临界区的标志清除。
            剩余区：代码中的其余部分。
        同步
            同步一程直接制约关系，它是指为完成某种任务而建立的两个或多个进程。这些进程因为需要在某些位置上协调它们的工作次序而等待、
            传递信息所产生的制约关系。进程间的直接制约关系就说源于它们之间的相互合作。
        互斥
            互斥亦称间接制约关系。当一个进程进入临界区使用临界资源时，另一个进程必须等待，当占用临界资源的进程退出临界区后，另一进程才允许去访问此临界资源。
        为禁止两个进程同时进入临界区，同步机制应遵循以下准则：
            空闲让进：临界区空闲时，可以允许一个请求进入临界区的进行立即进入临界区。
            忙则等待：当已有进程进入临界区时，其他试图进入临界区的进程必须等待。
            有限等待：对请求访问的进程，应保证能在有限时间内进入临界区。
            让权等待：当进程不能进入临界区时，应当立即释放处理器，防止进程忙等待。
        实现临界区互斥方法：
        软件层面：在进入临界区设置和检查一些标志来表明是否有进程在临界区中，如果已有进程在临界区，则在进入区通过循环检测等待，进程离开临界区后则在退出区修改标志。
            单标志法：
                该算法设置一个公用整型变量turn,用于指示被允许进入临界区的进程编号，即若turn=0，则允许P0进程进入临界区。该算法可确保每次只允许一个进程进入临界区。
                但两个进程必须交替进入临界区，如果某个进程不再进入临界区了，那么另一个进程也将进入临界区（违背“空闲让进”）这样很容易造成资源利用的不充分。
            双标志法：
                该算法的基本思想是在每一个进程访问临界区资源之前，先查看一下临界资源是否正被访问，若正被访问，该进程需等待；否则，进程才进入自己的临界区。
                为此，设置了一个数据flag[i]，如第i个元素值为FALSE，表示Pi进程未进入临界区，值为TRUE，表示Pi进程进入临界区。
            双标志法后检查：
                双标志法是先检测对方进程状态标志后，再置自己标志，由于在检测和放置中可插入另一个进程到达时的检测操作，会造成两个进程在分别检测后，
                同时进入临界区。为此，双标志法后检查釆用先设置自己标志为TRUE后,再检测对方状态标志，若对方标志为TURE，则进程等待；否则进入临界区。
                但是当两个进程几乎同时都想进入临界区时，它们分别将自己的标志值flag设置为TRUE，并且同时检测对方的状态（执行while语句），
                发现对方也要进入临界区，于是双方互相谦让，结果谁也进不了临界区，从而导致“饥饿”现象。
            Peterson’s Algorithm：
                为了防止两个进程为进入临界区而无限期等待，又设置变量turn，指示不允许进入临界区的进程编号，每个进程在先设置自己标志后再设置turn 标志，不允许另一个进程进入。
                这时，再同时检测另一个进程状态标志和不允许进入标志，这样可以保证当两个进程同时要求进入临界区，只允许一个进程进入临界区。
        硬件层面：计算机提供了特殊的硬件指令，允许对一个字中的内容进行检测和修正，或者是对两个字的内容进行交换等。通过硬件支持实现临界段问题的低级方法或称为元方法。
            中断屏蔽方法：
                当一个进程正在使用处理机执行它的临界区代码时，要防止其他进程再进入其临界区访问的最简单方法是禁止一切中断发生，或称之为屏蔽中断、关中断。因为CPU只在发生中断时引起进程切换，
                这样屏蔽中断就能保证当前运行进程将临界区代码顺利地执行完，从而保证了互斥的正确实现，然后再执行开中断。
                这种方法限制了处理机交替执行程序的能力，因此执行的效率将会明显降低。对内核来说，当它执行更新变量或列表的几条指令期间关中断是很方便的，
                但将关中断的权力交给用户则很不明智，若一个进程关中断之后不再开中断，则系统可能会因此终止。
                硬件指令方法
            TS（Test-and-Set）指令
                TS指令的功能是读出指定标识后把该标志设置为TRUE。
                每个临界资源设置公共布尔变量lock，表示资源两种状态：TRUE表示正被占用，FALSE表示空闲，初始值为FALSE。
                有进程在临界区时，重复检查，直到其他进程退出时检查通过，所有要访问临界资源的进程的进入区和退出区代码是相同的。
            Swap指令
                利用Swap指令实现的进程互斥算法是，每个临界资源设置一个公共布尔变量lock，初值为FALSE，每个进程设置一个私有布尔变量key，用于与lock间的信息交换。
                在进入区利用Swap指令交换lock和key的内容，然后检查key的状态，有进程在临界区时，重复交换和检查过程直到其他进程推出后检查通过。
         信号量
             信号量机制所使用的P、V原语就来自荷兰语test和increment。每个信号量s除一个整数值s.count（计数）外，还有一个进程等待队列s.queue，其中存放的是阻塞在该信号量的各个进程的标识。
             信号量只能通过初始化和标准的原语来访问。
             P、V原语的执行，不受进程调度和执行的打断，从而很好地解决了原语操作的整体性。信号量的初始化可指定一个非负整数数值，表示空闲资源总数；若为负值，其绝对值表示当前等待临界区的进程数。
         互斥量（mutex）
            其实是信号量的一种特例，它的值只有 0 和 1，当我们不需要用到信号量的计数能力时，我们可以使用互斥量，实际上也意味着临界区值同一时间只允许一个进程进入，而信号量是允许多个进程同时进入临界区的

22. LockSupport实现原理

    
        https://cloud.tencent.com/developer/article/1198491
        https://www.jianshu.com/p/4d19684917d2
        https://www.jianshu.com/p/e3afe8ab8364
        https://kkewwei.github.io/elasticsearch_learning/2018/11/10/LockSupport%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/
        https://juejin.im/post/5bdc1142e51d45052c6fede7
        LockSupport用来创建锁和其他同步类的基本线程阻塞原语。
        LockSupport为每个使用它的线程提供一个许可管理。如果该许可可用，则调用park会消耗此许可并立即返回；
        否则线程可能阻塞。如果许可尚不可用，调用unpark则使其这个许可可用，但是这个许可是不能累积的，并且最多只能有一个许可。
        LockSupport相对比Object的wait/notify/notifyAll具有以下的优势：
            1. LockSupport不需要在同步代码块里。所有线程间也不需要维护一个共享的同步对象了，实现了线程间的解耦。
            2. unpark函数可以先于park调用，不需要担心线程间的执行先后顺序。
        LockSupport实现原理
        LockSupport的park和unpark都是调用的Unsafe了的静态方法。
        Unsafe是个不安全的类，它可以直接操作内存，只有受信任的类才可以使用它。
        Unsafe的park和unpark会调用thread的parker()的park()，parker()会返回一个Parker类，最终会调用Parker的park方法（thread->parker()->park(isAbsolute != 0, time)）。
        每个Java线程都有一个Parker类：
        class Parker : public os::PlatformParker {
        private:
          volatile int _counter ;
          ...
        public:
          void park(bool isAbsolute, jlong time);
          void unpark();
          ...
        }
        class PlatformParker : public CHeapObj<mtInternal> {
          protected:
          pthread_mutex_t _mutex [1] ;
          pthread_cond_t  _cond  [1] ;
        ...
        }
        在Linux系统下，Parker的park和unpark是使用Posix线程库的pthread中的mutex（互斥量），condition（条件变量）这两个原语来实现的
        mutex和condition保护一个_counter的变量，当park时，这个变量被设置为0，当unpark时，这个变量被设置为1。
        park过程：
        void Parker::park(bool isAbsolute, jlong time) {
          // Ideally we'd do something useful while spinning, such
          // as calling unpackTime().
          // Optional fast-path check:
          // Return immediately if a permit is available.
          // We depend on Atomic::xchg() having full barrier semantics
          // since we are doing a lock-free update to _counter.
           //这里通过原子操作来完成_counter清零操作。 若_counter之前>0, 那么说明之前该线程被unpark()过, 就可以直接返回而不被阻塞。
          if (Atomic::xchg(0, &_counter) > 0) return;
          Thread* thread = Thread::current();
          assert(thread->is_Java_thread(), "Must be JavaThread");  //判断一定的是java线程
          JavaThread *jt = (JavaThread *)thread; //类强制转化
          // Optional optimization -- avoid state transitions if there's an interrupt pending.
          // Check interrupt before trying to wait
          //进入睡眠等待前先检查是否有中断信号, 若有中断信号也直接返回。
          if (Thread::is_interrupted(thread, false)) {
        return;
          }
          // Next, demultiplex/decode time arguments
          timespec absTime;
          //如果是按参数小于0，或者绝对时间，那么可以直接返回
          if (time < 0 || (isAbsolute && time == 0) ) { // don't wait at all
            return;
          }
           //如果时间大于0，判断阻塞超时时间或阻塞截止日期，同时将时间赋值给absTime
          if (time > 0) {
            unpackTime(&absTime, isAbsolute, time);
          }
          // Enter safepoint region
          // Beware of deadlocks such as 6317397.
          // The per-thread Parker:: mutex is a classic leaf-lock.
          // In particular a thread must never block on the Threads_lock while
          // holding the Parker:: mutex.  If safepoints are pending both the
          // the ThreadBlockInVM() CTOR and DTOR may grab Threads_lock.
          ThreadBlockInVM tbivm(jt);
          // Don't wait if cannot get lock since interference arises from
          // unblocking.  Also. check interrupt before trying wait
          //再次检查, 如果有中断信号。直接返回; 或者申请互斥锁失败，则直接返回pthread_mutex_trylock返回0。任何其他返回值都表示错误。
          //函数pthread_mutex_trylock是POSIX 线程pthread_mutex_lock的非阻塞版本。
          if (Thread::is_interrupted(thread, false) || pthread_mutex_trylock(_mutex) != 0) {
            return;
          }
          //此时已经通过_mutex将该代码进行了互斥操作, 那么直接对_counter都是安全的
          int status ;
          如果count>0, 说明之前原子操作赋值为0没有成功。 而_counter> 0, 线程可以直接不阻塞而返回
          if (_counter > 0)  { // no wait needed
         //将_counter直接清零
         _counter = 0;
        //释放锁并返回， 返回0代表释放锁成功
        status = pthread_mutex_unlock(_mutex);
        assert (status == 0, "invariant") ; //这里会去检查一下是否成功了
        // Paranoia to ensure our locked and lock-free paths interact
        // correctly with each other and Java-level accesses.
        OrderAccess::fence(); //这个函数是HotSpot VM对JMM的内存屏障一个具体的实现函数;
        return;
          }
        #ifdef ASSERT
          // Don't catch signals while blocked; let the running threads have the signals.
          // (This allows a debugger to break into the running thread.)
          sigset_t oldsigs;
          sigset_t* allowdebug_blocked = os::Linux::allowdebug_blocked_signals();
          pthread_sigmask(SIG_BLOCK, allowdebug_blocked, &oldsigs);
        #endif
          OSThreadWaitState osts(thread->osthread(), false /* not Object.wait() */);
          jt->set_suspend_equivalent();
          // cleared by handle_special_suspend_equivalent_condition() or java_suspend_self()
          assert(_cur_index == -1, "invariant");
         //若没有超时时间，那么本线程将进入睡眠状态并释放cpu、释放对_mutex的锁定，等待其他线程调用pthread_cond_signal唤醒该线程；唤醒后会获取对_mutex的锁定的锁定
          if (time == 0) {
        _cur_index = REL_INDEX; // arbitrary choice when not timed
        status = pthread_cond_wait (&_cond[_cur_index], _mutex) ;
          } else {
        _cur_index = isAbsolute ? ABS_INDEX : REL_INDEX;
         //开始真正的阻塞，超时等待，或者其他线程pthread_cond_signal唤醒该线程
        status = os::Linux::safe_cond_timedwait (&_cond[_cur_index], _mutex, &absTime) ;
        if (status != 0 && WorkAroundNPTLTimedWaitHang) {
          pthread_cond_destroy (&_cond[_cur_index]) ;
          pthread_cond_init(&_cond[_cur_index], isAbsolute ? NULL : os::Linux::condAttr());
        }
          }
          _cur_index = -1;
          assert_status(status == 0 || status == EINTR ||
        status == ETIME || status == ETIMEDOUT,
        status, "cond_timedwait");
        #ifdef ASSERT
          pthread_sigmask(SIG_SETMASK, &oldsigs, NULL);
        #endif
        //该线程被唤醒了, 同时也对_mutex加锁了, 置位_counter是线程安全的
          _counter = 0 ;
          //解锁_mutex
          status = pthread_mutex_unlock(_mutex) ;
          assert_status(status == 0, status, "invariant") ;
          // Paranoia to ensure our locked and lock-free paths interact
          // correctly with each other and Java-level accesses.
          OrderAccess::fence(); //内存屏障
          // If externally suspended while waiting, re-suspend
          if (jt->handle_special_suspend_equivalent_condition()) {
        jt->java_suspend_self();
          }
        }
        1. 先尝试使用 Atomic 的 xchg，CAS 查看 counter 是否大于 0，如果是，那么更新为 0，返 回。
        2. 检查该线程是否有中断信号，有直接返回。
        3. 尝试使用pthread_mutex_trylock对_mutex加锁来达到线程互斥。
        4. 根据等待时间调用不同的等待函数（safe_cond_timedwait/pthread_cond_wait）等待，等待其他线程pthread_cond_signal调用唤醒。
        5. 设置_counter为0。
        6. 通过pthread_mutex_unlock对mutex解锁。
        需要了解下: safe_cond_timedwait/pthread_cond_wait在执行之前肯定已经获取了锁_mutex, 在睡眠前释放了锁, 在被唤醒之前, 首先再取唤醒锁。

        unpark过程
        void Parker::unpark() {
          int s, status ;
          //首先是互斥获取锁
          status = pthread_mutex_lock(_mutex);
          assert (status == 0, "invariant") ;
          s = _counter;
          //只要把这个状态置为1就行了，就是说多次调用unpack()没啥意义
          _counter = 1;
           //s只能为0，说明没有人调用unpark
          if (s < 1) {
        // thread might be parked
        if (_cur_index != -1) {
          // thread is definitely parked
          //线程已经处于parker状态了
          if (WorkAroundNPTLTimedWaitHang) {
           //pthread_cond_signal可以唤醒pthread_cond_wait()被&_cond[_cur_index]阻塞的线程
        status = pthread_cond_signal (&_cond[_cur_index]);
        assert (status == 0, "invariant");
        //解锁
        status = pthread_mutex_unlock(_mutex);
        assert (status == 0, "invariant");
          } else {
        status = pthread_mutex_unlock(_mutex);
        assert (status == 0, "invariant");
        status = pthread_cond_signal (&_cond[_cur_index]);
        assert (status == 0, "invariant");
          }
        } else {
          //仅仅解锁
          pthread_mutex_unlock(_mutex);
          assert (status == 0, "invariant") ;
        }
          } else {
        pthread_mutex_unlock(_mutex);
        assert (status == 0, "invariant") ;
          }
        }
        1. 首先获取锁_mutex。
        2. 对_counter置为1, 而不管之前什么值, 这里说明无论多少函数调用unpark(), 都是无效的, 只会记录一次。
        3. 检查线程是否已经被阻塞了, 若已经阻塞了,调用pthread_cond_signal唤醒唤醒。
        释放对_mutex的锁定。


23. AbstractQueuedSynchronized（同步器）


        http://ifeve.com/introduce-abstractqueuedsynchronizer/
        https://wiki.jikexueyuan.com/project/java-concurrent/thread-communication.html
        https://zhuanlan.zhihu.com/p/34921540
        https://segmentfault.com/a/1190000008471362
        https://liuzhengyang.github.io/2017/05/12/aqs/
        https://www.jianshu.com/p/df0d7d6571de
        https://www.jianshu.com/p/4682a6b0802d
        https://qilu.me/2018/10/18/2018-10-18/
        https://www.cnblogs.com/micrari/p/6937995.html
        https://segmentfault.com/a/1190000014721183
        http://gee.cs.oswego.edu/dl/papers/aqs.pdf
        http://ifeve.com/aqs-1/#introduction
        http://www.throwable.club/2019/04/07/java-juc-aqs-source-code/
        AbstractQueueSynchronized为其他同步器提供一个基础框架。大部分同步器都是用来保护某个区域（临界区）的代码，这些代码可能被多线程并发访问。因此设计
        同步器的基础框架一般涉及到如下功能：
            1. 状态（确定线程的访问权限）。
            2. 访问条件（用来检查线程是否具有访问权限，一般使用while进行自旋检测避免线程虚假唤醒）。
            3. 状态变化 (一旦线程获取对临界区的访问权限，需要变更状态防止其他线程进入临界区)。
            4. 通知策略（当一个线程改变了同步器的状态，需要通知其他线程状态）。
            5. Test-and-Set 方法(线程原子性的检查和更改同步器的状态)。
                5-1：如有必要，在检查前先设置状态
                5-2：检查访问条件
                5-3：如果如果条件不满足，则等待
                5-4：如果访问条件满足，设置状态，如果必要还需要通知通知其他线程
        AbstractQueueSynchronized通过一个int类型的state字段表示同步状态，通过getState,setState,compareAndSetState来原子性的检查同步器的状态。
        内部通过CLH队列(CLH的变种)来维护同步线程，通过LookSupport的park和unpark阻塞和唤醒线程。
        CLH队列是一种基于单向链表的高性能、公平的自旋锁。申请加锁的线程通过前驱节点的变量进行自旋。在前置节点解锁后，当前节点会结束自旋，并进行加锁。
        AQS针对阻塞同步器时，当状态变化时，需要主动的去唤醒（unpark）队列的后继节点(next)，因此对CLH队列进行了改造，使用CLH双链表结构。
        // 实现原理
        // 线程节点
        static final class Node {
            volatile int waitStatus; // 同步状态
            volatile Node prev; // 前驱节点
            volatile Node next; // 后继节点
            Node nextWaiter; // Condition队列的后继节点
            volatile Thread thread;//入队时线程
        }
        // 同步状态
        1. CANCELLED（1） 当前线程被取消
        2. SIGNAL（-1） 当前节点的后继节点需要被唤醒(unpark)(后继节点处于BLOCKED或者即将处于BLOCKED状态（park）时需要设置前驱节点的状态为SIGNAL)
        3. CONDITION （-2）当前节点处于Condition队列中，不存在sync队列中，直到Condition通知才会把Condition队列的节点转移到sync队列中
        4. PROPAGATE（-3）后续获取共享式的同步状态将会无条件的传播下去
        5. 0 初始状态。
        // 成员变量
        private volatile int state; //同步状态标志
        private transient volatile Node head;//头节点
        private transient volatile Node tail;//尾节点
        // AQS提供独占和共享两种模式，独占模式下，只有一个线程可以执行访问，其他线程都会阻塞；共享模式则有可能有多个线程可以执行访问。
        // AQS没有实现任何同步接口，通过getState,setState,compareAndSetState来进行状态的变更，AQS通过以下方法
            tryAcquire(int)
            tryRelease(int)
            tryAcquireShared(int)
            tryReleaseShared(int)
            isHeldExclusively()
        // 为其他同步器提供同步支持，其他同步器必须在线程安全情况下非阻塞实现这些方法。默认AQS独占式的提供操作同步状态的方法acquire和release和共享式的acquireShared和releaseShared
        // 同时提供中断和超时版本acquireInterruptibly,acquireSharedInterruptibly,tryAcquireNanos,tryAcquireSharedNanos为其他同步器提供更丰富的接口
        // acquire
        public final void acquire(int arg) {
            if (!tryAcquire(arg) &&
                acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
                // 如果在阻塞线程中发生了中断则调用线程的interrupt进行中断，线程是否中断取决于线程的运行状态，
                selfInterrupt();
        }
        // 1. tryAcquire获取锁(原子性更改同步状态，更改成功表示获取成功)。
        // 2. addWaiter(Node.EXCLUSIVE) 构建新节点添加到sync队列尾部。
        // 3. acquireQueued 循环自旋检查前驱节点是否是头节点且是否能够tryAcquire获取锁，否则阻塞(park)
        private Node addWaiter(Node mode) {
            //构建新节点
            Node node = new Node(mode);
            // 循环直到节点添加到sync尾部
            for (;;) {
                Node oldTail = tail;
                if (oldTail != null) {
                    // 将新节点的前驱节点指向尾节点
                    U.putObject(node, Node.PREV, oldTail);
                    // 将新的节点设置成尾部节点
                    if (compareAndSetTail(oldTail, node)) {
                        // 原来的尾部节点的后继节点指向新的尾节点
                        oldTail.next = node;
                        return node;
                    }
                } else {
                    // 如果sync队列为空，构建虚拟节点，并将头尾节点指向虚拟节点
                    initializeSyncQueue();
                }
            }
        }
        private final void initializeSyncQueue() {
            Node h ;
            Node h;
            if (U.compareAndSwapObject(this, HEAD, null, (h = new Node())))
                tail = h;
        }
        private final boolean compareAndSetTail(Node expect, Node update) {
            return U.compareAndSwapObject(this, TAIL, expect, update);
        }
        // 设置头节点，尾节点，设置节点的前驱节点都是通过Unsafe提供的方法进行CAS操作来保证操作的原子性
        final boolean acquireQueued(final Node node, int arg) {
            try {
                boolean interrupted = false;
                // 自旋检查是否能够获取锁
                for (;;) {
                    final Node p = node.predecessor();
                    // 只有前驱节点是头节点才能去获取锁
                    if (p == head && tryAcquire(arg)) {
                        // 成功获取锁，设置新的头节点
                        setHead(node);
                        // 释放前驱节点
                        p.next = null; // help GC
                        return interrupted;
                    }
                    // 阻塞线程
                    if (shouldParkAfterFailedAcquire(p, node) &&
                        parkAndCheckInterrupt())
                        // 如果阻塞线程中由于中断返回则设置中段标志
                        interrupted = true;
                }
            } catch (Throwable t) {
                // 异常情况
                cancelAcquire(node);
                throw t;
            }
        }
        // shouldParkAfterFailedAcquire首先原子性的设置前驱节点的同步状态为SIGNAL
        private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {
            int ws = pred.waitStatus;
            if (ws == Node.SIGNAL)
                // 如果前驱节点的同步状态已经是SIGNAL表示可以安全的阻塞当前线程
                return true;
            if (ws > 0) {
                // 如果前驱节点被取消，我们需要往前寻找同步状态不是CANCELLED的节点作为此节点的前驱节点
                do {
                    node.prev = pred = pred.prev;
                } while (pred.waitStatus > 0);
                pred.next = node;
            } else {
                // CAS更改前驱节点的同步状态为SIGNAL
                pred.compareAndSetWaitStatus(ws, Node.SIGNAL);
            }
            return false;
        }
        // parkAndCheckInterrupt使用LookSupport阻塞当前线程同时线程唤醒返回时需要检查是否是中断返回
        private final boolean parkAndCheckInterrupt() {
            LockSupport.park(this);
            return Thread.interrupted();
        }
        // release
        public final boolean release(int arg) {
            // 尝试释放锁
            if (tryRelease(arg)) {
                Node h = head;
                // 唤醒头节点的后继节点线程(因为成功获取到锁的线程都会设置成头节点)
                if (h != null && h.waitStatus != 0)
                    unparkSuccessor(h);
                return true;
            }
            return false;
        }

        private void unparkSuccessor(Node node) {
            // 如果节点的同步状态是负数，需要原子性更改成同步状态为0
            int ws = node.waitStatus;
            if (ws < 0)
                node.compareAndSetWaitStatus(ws, 0);

            // 后继节点
            Node s = node.next;
            // 如果后继节点为空或者后继节点的同步状态为CANCELLED则从尾到当前节点查找同步状态不是CANCELLED的节点作为后继节点
            if (s == null || s.waitStatus > 0) {
                s = null;
                for (Node p = tail; p != node && p != null; p = p.prev)
                    if (p.waitStatus <= 0)
                        s = p;
            }
            // 存在后继节点则唤醒后继节点线程
            if (s != null)
                LockSupport.unpark(s.thread);
        }
        // acquireShared
        public final void acquireShared(int arg) {
            if (tryAcquireShared(arg) < 0)
                doAcquireShared(arg);
        }
        // 1. tryAcquireShared尝试获取共享锁
                1-1. 返回值小于0代表获取失败
                1-2. 返回值等于0表示获取成功且后续的线程无法获取共享锁
                1-3. 返回值大于0表示获取成功但是后续等待的节点线程有可能获取共享锁成功，也就是说需要唤醒后续节点线程去尝试获取共享锁
        // 2. 获取共享锁失败进入doAcquireShared流程
        private void doAcquireShared(int arg) {
            // 构造共享节点并加入到sync队列的尾部
            final Node node = addWaiter(Node.SHARED);
            try {
                boolean interrupted = false;
                // 自旋检查是否能够获取共享锁
                for (;;) {
                    final Node p = node.predecessor();
                    // 只有前驱节点是头节点才能去获取共享锁
                    if (p == head) {
                        // tryAcquireShared尝试获取共享锁
                        int r = tryAcquireShared(arg);
                        // 当前节点线程成功获取到共享锁
                        if (r >= 0) {
                            // 设置当前节点为新的头节点并向后继续唤醒后继节点线程去尝试获取共享锁
                            setHeadAndPropagate(node, r);
                            // 释放前驱节点
                            p.next = null; // help GC
                            // 如果在阻塞线程中发生了中断则调用线程的interrupt进行中断，线程是否中断取决于线程的运行状态，
                            if (interrupted)
                                selfInterrupt();
                            return;
                        }
                    }
                    // 获取共享锁失败阻塞线程
                    if (shouldParkAfterFailedAcquire(p, node) &&
                        parkAndCheckInterrupt())
                        // 如果阻塞线程中由于中断返回则设置中段标志
                        interrupted = true;
                }
            } catch (Throwable t) {
                // 异常情况
                cancelAcquire(node);
                throw t;
            }
        }
        // 以上步骤可以看出，获取共享锁的步骤跟获取独占锁的步骤基本上是一致的：
            1. 尝试获取锁
            2. 获取失败则构造Node节点加入sync队列尾部
            3. 自旋检查访问条件是否满足获取锁
            4. 设置新的头节点(共享锁可能需要向后唤醒后继节点线程)
            5. 阻塞检查和检查阻塞是否中断唤醒来决定是否进行线程中断操作
        private void setHeadAndPropagate(Node node, int propagate) {
            Node h = head; // Record old head for check below
            // 设置新的头节点
            setHead(node);
             // 需要唤醒后继节点线程的情况
            //      1. propagate（tryAcquireShared返回值)大于0说明可以继续向后唤醒线程获取共享锁
            //      2. 检查旧的头节点是否为空和旧的头节点的同步状态是否小于0
            //      3. 检查新的头节点是否为空和新的头节点的同步状态是否小于0
            if (propagate > 0 || h == null || h.waitStatus < 0 ||
                (h = head) == null || h.waitStatus < 0) {
                Node s = node.next;
                // 后继节点为空或者后继节点是共享节点需要释放当前同步状态并进行唤醒
                if (s == null || s.isShared())
                    doReleaseShared();
            }
        }
        private void doReleaseShared() {
            for (;;) {
                Node h = head;
                // sync队列不止一个节点
                if (h != null && h != tail) {
                    int ws = h.waitStatus;
                    // 头节点同步状态为SIGNAL需要后续后继节点线程
                    if (ws == Node.SIGNAL) {
                        // 唤醒前先CAS设置同步状态为0
                        if (!h.compareAndSetWaitStatus(Node.SIGNAL, 0))
                            continue;            // loop to recheck cases
                        // 唤醒后继节点线程
                        unparkSuccessor(h);
                    }
                    // 头节点同步状态为0需要CAS设置同步状态为PROPAGATE以便传播链的传播
                    else if (ws == 0 &&
                             !h.compareAndSetWaitStatus(0, Node.PROPAGATE))
                        continue;                // loop on failed CAS
                }
                // 如果头节点更改过，需要重试
                if (h == head)                   // loop if head changed
                    break;
            }
        }
        // 首先这里要弄明白上诉两个方法的几个疑问点
            1. doReleaseShared当同步状态为0时为啥需要CAS设置同步状态为PROPAGATE
            2. doReleaseShared为啥需要判断h == head
            3. doReleaseShared为啥需要循环重试
            4. setHeadAndPropagate的为啥需要新老两次头节点判断(h == null || h.waitStatus < 0)
        // 其实上诉条件都是为了确保sync队列的传播链不会中断。具体原因可以参考https://qilu.me/2018/10/18/2018-10-18/这文章
        // cancelAcquire情况
        private void cancelAcquire(Node node) {
            // Ignore if node doesn't exist
            if (node == null)
                return;

            node.thread = null;

            // 跳过前驱节点为CANCELLED的节点
            Node pred = node.prev;
            while (pred.waitStatus > 0)
                node.prev = pred = pred.prev;

            // 前驱节点的后继节点
            Node predNext = pred.next;

            // 如果节点是后续节点，设置尾节点为前驱节点
            if (node == tail && compareAndSetTail(node, pred)) {
                // 前驱的后继置为null,因此此时前驱节点已经是尾节点
                pred.compareAndSetNext(predNext, null);
            } else {
                int ws;
                // 如果前驱节点不是头节点需要将前驱节点和待删节点的后继节点进行链接
                if (pred != head &&
                    ((ws = pred.waitStatus) == Node.SIGNAL ||
                     (ws <= 0 && pred.compareAndSetWaitStatus(ws, Node.SIGNAL))) &&
                    pred.thread != null) {
                    // 待删节点的后继节点
                    Node next = node.next;
                    // 将前驱节点和待删节点的后继节点进行链接
                    if (next != null && next.waitStatus <= 0)
                        pred.compareAndSetNext(predNext, next);
                } else {
                    // 如果前驱节点是头节点我们需要唤醒它
                    unparkSuccessor(node);
                }
                // 取消节点的next之所以设置为自己本身而不是null,
                // 是为了方便AQS中Condition部分的isOnSyncQueue方法,
                // 判断一个原先属于条件队列的节点是否转移到了同步队列。
                // 因为同步队列中会用到节点的next域，取消节点的next也有值的话，
                // 可以断言next域有值的节点一定在同步队列上。
                // 在GC层面，和设置为null具有相同的效果。
                node.next = node; // help GC
            }
        }
        // Condition支持管程形式的await/signal/signalAll操作，代替了Object了基于JNI提供的wait/notify/notifyAll。
        // AQS中通过内部的ConditionObject来实现Condition条件队列，通过ConditionObject的await/signal来实现管程的Condition相同的功能。
        // AQS中ConditionObject是一个单列表实现通过Node节点的下一个nextWaiter来链接下一个Condition节点，同时通过同步状态waitStatus为CONDITION来标记处于同步队列中
        // ConditionObject成员变量
        // 条件队列第一个节点
        private transient Node firstWaiter;
        // 条件队列最后一个节点
        private transient Node lastWaiter;
        // 这里只分析await/signal方法，对于中断和超时版本不分析。
        public final void await() throws InterruptedException {
                if (Thread.interrupted())
                    throw new InterruptedException();
                // 构建新节点添加到条件队列尾部
                Node node = addConditionWaiter();
                // 释放锁
                int savedState = fullyRelease(node);
                int interruptMode = 0;
                // 自旋检查(防止线程虚假唤醒)是否存于sync队列中，因为线程中断或者signal会把节点转移到sync队列中
                while (!isOnSyncQueue(node)) {
                    // 阻塞线程等待signal/signalAll事件
                    LockSupport.park(this);
                    // 检查线程阻塞返回的原因
                    if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)
                        break;
                }
                // 重新请求锁
                if (acquireQueued(node, savedState) && interruptMode != THROW_IE)
                    interruptMode = REINTERRUPT;
                // 清除Condition队列中同步状态非CONDITION的节点
                if (node.nextWaiter != null) // clean up if cancelled
                    unlinkCancelledWaiters();
                // 中断或者异常处理
                if (interruptMode != 0)
                    reportInterruptAfterWait(interruptMode);
        }
        private Node addConditionWaiter() {
            Node t = lastWaiter;
            // 如果尾节点不是CONDITION节点则清除Condition队列中非CONDITION的节点
            if (t != null && t.waitStatus != Node.CONDITION) {
                unlinkCancelledWaiters();
                t = lastWaiter;
            }
            // 构建新节点
            Node node = new Node(Node.CONDITION);
            if (t == null)
                // Condition队列为空
                firstWaiter = node;
            else
                // 添加到Condition队列尾部
                t.nextWaiter = node;
            // 设置新的尾节点
            lastWaiter = node;
            return node;
        }
        // 清除Condition队列中同步状态非CONDITION的节点
        private void unlinkCancelledWaiters() {
            // 删除一个单链表节点的原理很简单：
            // 如果待删节点是首节点：将待删节点的后继节点置为null同时移动首节点；
            // 如果待删节点不是首节点：将待删节点的后继节点置为null同时将待删节点的前驱节点的nextWaiter指向待删节点的后继节点
            Node t = firstWaiter;
            // 这里使用一个节点（我们称为追踪节点）来记录待删节点的前驱节点
            Node trail = null;
            while (t != null) {
                // 记录后继节点
                Node next = t.nextWaiter;
                // 非CONDITION节点，需要从链表中进行删除
                if (t.waitStatus != Node.CONDITION) {
                    // 断链（删除节点nextWaiter置空）
                    t.nextWaiter = null;
                    // 删除节点在链表头
                    if (trail == null)
                        // 移动第一个节点
                        firstWaiter = next;
                    else
                        // 将追踪节点(待删节点的前驱节点)的nextWaiter指向待删节点的后继节点
                        trail.nextWaiter = next;
                    // 如果待删节点是最后一个节点（待删节点的后继节点为null），则需要设置新的lastWaiter节点
                    if (next == null)
                        lastWaiter = trail;
                }
                else
                    // 记录前驱节点
                    trail = t;
                t = next;
            }
        }
        // 释放锁
        final int fullyRelease(Node node) {
            try {
                // 获取当前同步状态
                int savedState = getState();
                // 释放锁
                if (release(savedState))
                    // 返回释放锁之前的同步状态
                    return savedState;
                // 如果释放锁不成功，那么必定是await方法之前没有进行加锁acquire，那么抛出IllegalMonitorStateException
                throw new IllegalMonitorStateException();
            } catch (Throwable t) {
                // 设置节点为CANCELLED，同时向外抛出异常
                node.waitStatus = Node.CANCELLED;
                throw t;
            }
        }
        // 判断节点是否位于sync队列中
        final boolean isOnSyncQueue(Node node) {
            // 如果节点waitStatus状态为CONDITION和前驱节点为null(sync节点前驱肯定不会为null)，则此节点不在sync队列中
            if (node.waitStatus == Node.CONDITION || node.prev == null)
                return false;
            // 如果节点存在后继节点则节点位于sync队列中
            if (node.next != null)
                return true;
            // 因为node.prev非null有可能是Condition队列节点转移到sync队列过程中CAS失败导致，所以需要重新遍历一遍sync队列进行比较
            // 从尾向头遍历比较
            return findNodeFromTail(node);
        }
        // findNodeFromTail方法不分析
        // 检查线程park返回的原因
        private int checkInterruptWhileWaiting(Node node) {
            return Thread.interrupted() ?
                // 如果是线程中断将节点传输到sync队列中，并判断中断是发生在signal前还是signal后来决定返回不同值
                // 其中THROW_IE(-1)表示中断发生在signal之前，REINTERRUPT（1）表示中断发生在signal之后
                (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :
                // signal唤醒则返回0
                0;
        }
        // 传输节点到sync队列中，如果中断发生在signal之前返回true,否则返回false
        final boolean transferAfterCancelledWait(Node node) {
            // CAS将节点同步状态CONDITION置为0，如果signal已经发生，那么CAS必然失败
            if (node.compareAndSetWaitStatus(Node.CONDITION, 0)) {
                // CAS成功，将Condition节点传输到sync队列尾部
                enq(node);
                return true;
            }
            // 如果上诉CAS失败，我们需要让出调度器，等待Condition节点传输到sync队列
            while (!isOnSyncQueue(node))
                Thread.yield();
            return false;
        }
        // acquireQueued重新获取锁,前面acquire已经分析
        // 根据interruptMode值来进行抛出中断异常或者进行自我中断操作
        private void reportInterruptAfterWait(int interruptMode)
            throws InterruptedException {
            if (interruptMode == THROW_IE)
                throw new InterruptedException();
            else if (interruptMode == REINTERRUPT)
                selfInterrupt();
        }
        // await实现核心步骤主要如下：
            1. 构建新节点添加到条件队列尾部
            2. 释放锁
            3. 阻塞等待其他Condition的signal/signalAll通知
            4. 重新请求锁
        // signal
        // signal唤醒wait的线程
        public final void signal() {
            // 是否持有锁
            if (!isHeldExclusively())
                // 没有抛出IllegalMonitorStateException异常
                throw new IllegalMonitorStateException();
            Node first = firstWaiter;
            // 唤醒Condition队列的一个节点线程并并传输到sync队列
            if (first != null)
                doSignal(first);
        }
        // 从Condition节点中删除一个节点传输到sync队列
        // 这个方法会循环直到成功传输到一个节点到sync队列或者直至Condition为空
        private void doSignal(Node first) {
            do {
                // 删除的节点是最后一个节点
                if ( (firstWaiter = first.nextWaiter) == null)
                    lastWaiter = null;
                // 断链
                first.nextWaiter = null;
            } while (!transferForSignal(first) &&
                     (first = firstWaiter) != null);
        }
        // 传输Condition节点并唤醒线程
        final boolean transferForSignal(Node node) {
             // 如果CAS修改同步状态失败,那么这个节点同步状态已经修改(CANCELLED),返回false
            if (!node.compareAndSetWaitStatus(Node.CONDITION, 0))
                return false;

            // 将节点插入到sync队列尾部,并返回其前驱节点
            Node p = enq(node);
            // 前驱节点的同步状态
            int ws = p.waitStatus;
            // 如果前驱节点已经取消或者CAS设置前驱节点的同步状态为SIGNAL失败则唤醒节点线程
            if (ws > 0 || !p.compareAndSetWaitStatus(ws, Node.SIGNAL))
                // 唤醒节点线程
                LockSupport.unpark(node.thread);
            return true;
        }
        // signal实现核心步骤主要如下：
            1. 传输Condition的一个节点到Sync队列中
            2. 唤醒线程


24. ReentrantLock

        ReentrantLock是一种可重入的互斥锁, 具有synchronized方法和语句所访问的隐私监听器锁具有相同的行为和语义。
        ReentrantLock相比synchronized具有更丰富的功能同时使用也更加的灵活(例如可中断，超时等特性)，但是不易操作，加锁解锁需要手动进行。
        ReentrantLock一般典型用法如下：
        class X {
            private final ReentrantLock lock = new ReentrantLock();
            public void m() {
                lock.lock();
                try {
                    //...method body

                } finally {
                    lock.unlock();
                }
            }
        }
        ReentrantLock除了实现synchronized非公平锁外，ReentrantLock还提供公平锁的实现。
        公平锁和非公平锁的区别主要在于唤醒锁的节点线程和最新获取锁线程是否存在竞争来区分的：
            公平锁的实现是同步队列严格按照FIFO队列保证最先进入节点的线程最先获取锁, 如果同步队列中存在节点, 后进入的节点进入同步队列而不是去竞争锁。
            非公平锁的实现是最新获取锁的线程首先会去尝试竞争锁而不管同步队列是否存在等待的线程节点。
        // ReentrantLock实现
        // 成员变量
        // AQS内部实现类
        private final Sync sync;
        // 构造函数，默认实现是非公平锁
        public ReentrantLock(boolean fair) {
            sync = fair ? new FairSync() : new NonfairSync();
        }
        // AQS实现了锁状态的管理和竞争锁线程管理等功能，Sync内部类实现了AQS的功能，ReentrantLock通过实现Lock锁的接口，当调用Lock锁接口时通过内部委托的方式委托给AQS来实现
        // Sync实现
        abstract static class Sync extends AbstractQueuedSynchronizer {
            private static final long serialVersionUID = -5179523762034025860L;

            // 具体有FairSync和NonfairSync来实现
            abstract void lock();

            // 非公平锁版本tryAcquire的实现
            final boolean nonfairTryAcquire(int acquires) {
                // 获取当前线程
                final Thread current = Thread.currentThread();
                // 获取锁状态
                int c = getState();
                // 如果锁状态为无锁状态(0表示没有线程持有锁)
                if (c == 0) {
                    // CAS修改锁状态
                    if (compareAndSetState(0, acquires)) {
                        //记录持有锁线程
                        setExclusiveOwnerThread(current);
                        return true;
                    }
                }
                // 如果锁状态为有锁状态且持有锁线程和当前线程一致则表示重复获取锁(可重入)
                else if (current == getExclusiveOwnerThread()) {
                    // 将state锁状态进行递增
                    int nextc = c + acquires;
                    // 可重入次数太多导致int型整数溢出，则抛出异常
                    if (nextc < 0) // overflow
                        throw new Error("Maximum lock count exceeded");
                    // 修改新的state锁状态值
                    setState(nextc);
                    return true;
                }
                return false;
            }
            // 释放锁
            protected final boolean tryRelease(int releases) {
                // 将锁状态的值减去releases(这里是1)
                int c = getState() - releases;
                // 如果当前线程不是持有锁线程则抛出IllegalMonitorStateException
                if (Thread.currentThread() != getExclusiveOwnerThread())
                    throw new IllegalMonitorStateException();
                boolean free = false;
                // 锁状态为0则释放锁
                if (c == 0) {
                    free = true;
                    // 设置持有锁线程为null
                    setExclusiveOwnerThread(null);
                }
                // 设置锁状态值
                setState(c);
                return free;
            }
            // 通过持有锁线程是否是当前线程来判断当前线程是否持有锁
            protected final boolean isHeldExclusively() {
                return getExclusiveOwnerThread() == Thread.currentThread();
            }
            // Condition队列的实现
            final ConditionObject newCondition() {
                return new ConditionObject();
            }
            // 获取持有锁的线程
            final Thread getOwner() {
                return getState() == 0 ? null : getExclusiveOwnerThread();
            }
            // 线程成功获取锁的次数
            final int getHoldCount() {
                return isHeldExclusively() ? getState() : 0;
            }
            // 通过同步状态判断是否是lock状态
            final boolean isLocked() {
                return getState() != 0;
            }

            // 反序列化锁恢复成无锁状态
            private void readObject(java.io.ObjectInputStream s)
                throws java.io.IOException, ClassNotFoundException {
                s.defaultReadObject();
                setState(0); // reset to unlocked state
            }
        }

        // 非公平锁实现NonfairSync
        static final class NonfairSync extends Sync {
            private static final long serialVersionUID = 7316153563782823691L;

             // 直接CAS尝试竞争锁，竞争失败或者已经获取锁后再次lock则进入AQS的acquire流程
            final void lock() {
                // CAS直接修改state同步状态
                if (compareAndSetState(0, 1))
                    // AQS默认继承AbstractOwnableSynchronizer类，AbstractOwnableSynchronizer类来记录持有锁的线程
                    // 设置持有锁线程
                    setExclusiveOwnerThread(Thread.currentThread());
                else
                    // CAS修改同步状态失败或者已经获取锁后再次lock进入AQS的acquire流程
                    acquire(1);
            }
            // 父类acquire方法首先会尝试调用tryAcquire模板方法(由子类实现)来尝试去获取锁
            protected final boolean tryAcquire(int acquires) {
                // nonfairTryAcquire分析查看上述Sync分析
                return nonfairTryAcquire(acquires);
            }
        }
        // 公平锁实现FairSync
        static final class FairSync extends Sync {
            private static final long serialVersionUID = -3000897897090466540L;
            // 直接进入AQS的acquire流程
            final void lock() {
                acquire(1);
            }

            // 父类acquire方法首先会尝试调用tryAcquire模板方法(由子类实现)来尝试去获取锁
            protected final boolean tryAcquire(int acquires) {
                // 获取当前线程
                final Thread current = Thread.currentThread();
                // 获取锁状态
                int c = getState();
                // 如果锁状态为无锁状态(0表示没有线程持有锁)
                if (c == 0) {
                    // hasQueuedPredecessors来判断同步队列中是否存在节点线程或者队列的第一个节点线程是否是当前线程(保证公平性)
                    if (!hasQueuedPredecessors() &&
                        // 如果同步队列中为空或者队列的第一个节点线程是当前线程则进行CAS获取锁
                        compareAndSetState(0, acquires)) {
                        // 设置持有锁线程
                        setExclusiveOwnerThread(current);
                        return true;
                    }
                }
                // 如果锁状态为有锁状态且持有锁线程和当前线程一致则表示重复获取锁(可重入)
                else if (current == getExclusiveOwnerThread()) {
                    // 将state锁状态进行递增
                    int nextc = c + acquires;
                    // 可重入次数太多导致int型整数溢出，则抛出异常
                    if (nextc < 0)
                        throw new Error("Maximum lock count exceeded");
                    // 修改新的state锁状态值
                    setState(nextc);
                    return true;
                }
                return false;
            }
        }
        // 判断同步队列中是否存在节点线程或者队列的第一个节点线程是否是当前线程
        public final boolean hasQueuedPredecessors() {
            Node t = tail; // Read fields in reverse initialization order
            Node h = head;
            Node s;
            // 同步队列不为空或者同步队列第一个节点线程不是当前线程则返回true
            return h != t &&
                ((s = h.next) == null || s.thread != Thread.currentThread());
        }
        // tryLock不管是不是公平锁实现都会用非公平锁实现来尝试去获取锁
        public boolean tryLock() {
            return sync.nonfairTryAcquire(1);
        }
        // 不管公平锁还是非公平锁实现都会调用Sync的release实现
        public void unlock() {
            // 分析见上述Sync流程
            sync.release(1);
        }


